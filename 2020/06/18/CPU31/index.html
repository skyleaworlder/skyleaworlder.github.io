<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>从 100 开始的 Mars Vivado CPU31 小实验 | 遐想的空中宫殿</title><meta name="description" content="记 2020 春季学期 计算机组成原理实验 单周期 31 条指令 CPU"><meta name="keywords" content="OS,作业"><meta name="author" content="skyleaworlder"><meta name="copyright" content="skyleaworlder"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/skyleaworlder.png"><link rel="canonical" href="http://yoursite.com/2020/06/18/CPU31/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="从 100 开始的 Mars Vivado CPU31 小实验"><meta property="og:url" content="http://yoursite.com/2020/06/18/CPU31/"><meta property="og:site_name" content="遐想的空中宫殿"><meta property="og:description" content="记 2020 春季学期 计算机组成原理实验 单周期 31 条指令 CPU"><meta property="og:image" content="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=3392122441,2459756568&amp;fm=15&amp;gp=0.jpg"><meta property="article:published_time" content="2020-06-18T15:31:27.000Z"><meta property="article:modified_time" content="2021-05-08T10:16:27.436Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '4.2.1',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime: '',
  date_suffix: {"one_hour":"Just","hours":"hours ago","day":"days ago"},
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2021-05-08 18:16:27'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/skyleaworlder.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">28</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">29</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、前言"><span class="toc-number">1.</span> <span class="toc-text">一、前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、配置注意事项"><span class="toc-number">2.</span> <span class="toc-text">二、配置注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Mars-下的架构"><span class="toc-number">2.1.</span> <span class="toc-text">1. Mars 下的架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-为啥是-IP-核"><span class="toc-number">2.2.</span> <span class="toc-text">2. 为啥是 IP 核</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Mars-咋整"><span class="toc-number">2.3.</span> <span class="toc-text">3. Mars 咋整</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-比对工具"><span class="toc-number">2.4.</span> <span class="toc-text">4. 比对工具</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、指令分析"><span class="toc-number">3.</span> <span class="toc-text">三、指令分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-add"><span class="toc-number">3.1.</span> <span class="toc-text">1. add</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-addu"><span class="toc-number">3.2.</span> <span class="toc-text">2. addu</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-sub"><span class="toc-number">3.3.</span> <span class="toc-text">3. sub</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-subu"><span class="toc-number">3.4.</span> <span class="toc-text">4. subu</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-and"><span class="toc-number">3.5.</span> <span class="toc-text">5. and</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-or"><span class="toc-number">3.6.</span> <span class="toc-text">6. or</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-xor"><span class="toc-number">3.7.</span> <span class="toc-text">7. xor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-nor"><span class="toc-number">3.8.</span> <span class="toc-text">8. nor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-slt"><span class="toc-number">3.9.</span> <span class="toc-text">9. slt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-sltu"><span class="toc-number">3.10.</span> <span class="toc-text">10. sltu</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-sll"><span class="toc-number">3.11.</span> <span class="toc-text">11. sll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-srl"><span class="toc-number">3.12.</span> <span class="toc-text">12. srl</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-sra"><span class="toc-number">3.13.</span> <span class="toc-text">13. sra</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-sllv"><span class="toc-number">3.14.</span> <span class="toc-text">14. sllv</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-srlv"><span class="toc-number">3.15.</span> <span class="toc-text">15. srlv</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-srav"><span class="toc-number">3.16.</span> <span class="toc-text">16. srav</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-jr"><span class="toc-number">3.17.</span> <span class="toc-text">17. jr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-addi"><span class="toc-number">3.18.</span> <span class="toc-text">18. addi</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-addiu"><span class="toc-number">3.19.</span> <span class="toc-text">19. addiu</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-andi"><span class="toc-number">3.20.</span> <span class="toc-text">20. andi</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-ori"><span class="toc-number">3.21.</span> <span class="toc-text">21. ori</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-xori"><span class="toc-number">3.22.</span> <span class="toc-text">22. xori</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23-lw"><span class="toc-number">3.23.</span> <span class="toc-text">23. lw</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24-sw"><span class="toc-number">3.24.</span> <span class="toc-text">24. sw</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25-beq"><span class="toc-number">3.25.</span> <span class="toc-text">25. beq</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26-bne"><span class="toc-number">3.26.</span> <span class="toc-text">26. bne</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#27-slti"><span class="toc-number">3.27.</span> <span class="toc-text">27. slti</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28-sltiu"><span class="toc-number">3.28.</span> <span class="toc-text">28. sltiu</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#29-lui"><span class="toc-number">3.29.</span> <span class="toc-text">29. lui</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#30-j"><span class="toc-number">3.30.</span> <span class="toc-text">30. j</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31-jal"><span class="toc-number">3.31.</span> <span class="toc-text">31. jal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32-CPU31"><span class="toc-number">3.32.</span> <span class="toc-text">32. CPU31</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、控制信号"><span class="toc-number">4.</span> <span class="toc-text">四、控制信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#五、从开始到现在"><span class="toc-number">5.</span> <span class="toc-text">五、从开始到现在</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#六、从现在到开始"><span class="toc-number">6.</span> <span class="toc-text">六、从现在到开始</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-IMEM"><span class="toc-number">6.1.</span> <span class="toc-text">1. IMEM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-DMEM"><span class="toc-number">6.2.</span> <span class="toc-text">2. DMEM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-ALU"><span class="toc-number">6.3.</span> <span class="toc-text">3. ALU</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Regfile"><span class="toc-number">6.4.</span> <span class="toc-text">4. Regfile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-PCreg"><span class="toc-number">6.5.</span> <span class="toc-text">5. PCreg</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-CPU"><span class="toc-number">6.6.</span> <span class="toc-text">6. CPU</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-sccomp-dataflow"><span class="toc-number">6.7.</span> <span class="toc-text">7. sccomp_dataflow</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#七、写在最后"><span class="toc-number">7.</span> <span class="toc-text">七、写在最后</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=3392122441,2459756568&amp;fm=15&amp;gp=0.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">遐想的空中宫殿</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">从 100 开始的 Mars Vivado CPU31 小实验</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-06-18T15:31:27.000Z" title="Created 2020-06-18 23:31:27">2020-06-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-05-08T10:16:27.436Z" title="Updated 2021-05-08 18:16:27">2021-05-08</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">10.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>40min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>说从 100 开始是因为希望都能轻松做完这个小实验吧。</p>
<p>其实要说的话，对于我这种学习不是很认真的人来说，强制力是保证学习成果的一个方法。比如这学期计组水的要死，据说前几届学长学姐 CPU31 都是期中的小作业，而放在我们这届却变成了大作业，感觉上的话，学校的要求变低，对我来说，的的确确使得产出变低。</p>
<p>在学校 mips 上面的资料提供了 8 条指令的 CPU 开发过程。虽说 mips 上的教程很明显是从哪个 csdn 或者 cnblog 博主那里直接 cv 下来的，但是要说起依靠这些文档，用 verilog 实现一个仅仅支持 31 条指令的 CPU 还不算是很难。</p>
<p>首先根据老师推荐，debug 用的是 verilog 的系统函数，诸如 <code>fdisplay, display, fwrite</code>，并将结果和 <code>Mars</code> 上汇编结果进行对比。这么做其实没啥问题，就是有点费神。这里也是想不出啥其他更好的办法了。</p>
<p>由于这个学期实在是特殊，所以所有 cpu 的设计仅仅保证前仿真通过。众所周知，通过前仿真和后仿真是两个概念，第一次下板能不能行，还得看天命。半年下来，开发板给我的感觉就是：“这是一个能给我带来 <strong>无限可能</strong> 的东西”。（可能以各种方式暴毙）</p>
<p>下面就来说一下开始写 CPU 前的准备吧：</p>
<h3 id="二、配置注意事项"><a href="#二、配置注意事项" class="headerlink" title="二、配置注意事项"></a>二、配置注意事项</h3><h4 id="1-Mars-下的架构"><a href="#1-Mars-下的架构" class="headerlink" title="1. Mars 下的架构"></a>1. Mars 下的架构</h4><p>学校要求的（能够和 Mars 产生相同输出，与网站仿真产生相同输出）CPU 是 <strong>哈佛结构</strong>。<br>长话短说，之前学的 <strong>冯诺依曼结构</strong> 有一个重要的概念叫做 <strong>存储程序</strong>，差不多就是 “程序和数据同存在一个存储器中”。<br>而哈佛结构不是这样，其将程序和数据分开存储，也就是使用两个存储器，一为程序存储器（后称 <code>IMEM</code>），一为数据存储器（后称 <code>DMEM</code>）。<br>（上为哈佛结构，下为冯诺依曼结构）</p>
<p><img src="5-1.png" alt="5-1"></p>
<p><img src="5-2.png" alt="5-2"></p>
<p>并且还需要格外注意两个点：</p>
<p><strong>Mars 中 PC 从 0x0040_0000 开始</strong>，这意味着取指令要从这个地址开始，而不是想当然的 0x0000_0000。<br>这其实是因为 Mars 模拟器模拟的是 mips 体系结构。<br>咱们大一暑假的时候马马虎虎学过两周的汇编，那个汇编是 x86 汇编，和现在要用的这个 mips 是不一样的。<br>mips 在程序执行前，也会把内存单元划分成几个小段，其中 0x0040_0000 是 <strong>代码段的首地址</strong>（可能有错，不过我是这么理解的）。<br><strong>同时，这也意味着，PC 和 指令存储器 的首地址要做一个映射。</strong> 比如：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] PC, instruction_addr;</span><br><span class="line"><span class="comment">// code, code, code...</span></span><br><span class="line"><span class="keyword">assign</span> instruction_addr = PC - <span class="number">32'h0040_0000</span>;</span><br></pre></td></tr></table></figure>
<p><strong>Mars 中 DMEM 从 0x1001_0000 开始</strong>，这就好理解多了，说明这个地址是 Mars 模拟下的数据存储器的首地址。<br>把读写数据的地址，和传入的数据进行一个映射就可以了。</p>
<p>弄清了 PC 和 DMEM 首地址相关的事，就可以着手先把 IP 核配了。</p>
<h4 id="2-为啥是-IP-核"><a href="#2-为啥是-IP-核" class="headerlink" title="2. 为啥是 IP 核"></a>2. 为啥是 IP 核</h4><p>是因为测试数据并不是手敲 testbench 喂出来的，而是通过 coe 文件直接导入 IP 核搞的。<br>这里重述一遍官网教程吧：</p>
<p>第一步：<br>点击左侧的 IP Catalog，之后在右上角输入 <code>Distributed Memory Generator</code>，这个就是要用的 IP 核。<br>最后双击两个搜索结果的任意一个。</p>
<p><img src="5-3.png" alt="5-3"></p>
<p>第二步：<br>这么配一下，为什么是 2048 呢，这个太大了的话，Generate 起来很慢，如果太小了，又有可能装不下 coe 给出的指令。官网是这么配的，我觉得没必要改。<br>下面那个为什么是 32 呢，是因为这是个 32 位的 CPU，存的数据也是 32 位。<br>至于上面的 Component Name，随便改，不影响。</p>
<p><img src="5-4.png" alt="5-4"></p>
<p>其实没啥可说的，之后要到 RST 这里加载 coe 文件。<br>如果没有这一步的话，那么出来的 IP 核，实例化后里面什么都没有。</p>
<p><img src="5-5.png" alt="5-5"></p>
<p>点击红框圈选的按钮，就会弹出加载 coe 文件的界面。<br>对了，这个 <code>mips_31_mars_simulate.coe</code> 是 mips 网站仿真时使用的文件，这个过了就能交作业了。</p>
<p><img src="5-6.png" alt="5-6"></p>
<p><img src="5-7.png" alt="5-7"></p>
<p>没了，直接点 OK，之后按上面这个来，点击 Generate，IP 核就在生成当中了。<br>接着我们可以先把 IMEM 写出来。</p>
<h4 id="3-Mars-咋整"><a href="#3-Mars-咋整" class="headerlink" title="3. Mars 咋整"></a>3. Mars 咋整</h4><p>在这个网站上下载：<a href="http://courses.missouristate.edu/kenvollmar/mars/" target="_blank" rel="noopener">Mars 4_5 下载</a></p>
<p><img src="5-8.png" alt="5-8"></p>
<p>这 UI 有二十年前那味儿了。<br>下载下来的就是个 jar 文件，运行不了的话自行配环境，这不属于计组管的范畴。<br>总之点开之后，我要说的是，我们需要用到 Mars 的两个功能：</p>
<ol>
<li>加载 txt 文件，单步 / 多步调试；</li>
<li>根据 txt 文件生成对应的 coe 文件，以此喂给 IP 核。</li>
</ol>
<p>因为你看了那个 coe 之后会发现，里面都是 16 进制的符号，然而老师给的都是 txt 文件，里面都是货真价实的 mips 指令，肯定不能通过人工汇编，肯定不能自己手敲机器指令来喂给 IP 核。<br>所以得需要个工具。</p>
<p>对于第一点，如果我们做到了第二点，那么就需要一个权威的 mips 体系模拟器来做裁判，方便我们对自己写的代码 debug。这样结合一下 verilog 自带的 <code>fdisplay</code>，那就完美了。</p>
<p><img src="5-9.png" alt="5-9"></p>
<p>由于 Mars 操作过于简单，这些真的不用多说，直接加载一份 txt 文件。这里我们选的 addiu 的指令 txt。</p>
<p><img src="5-10.png" alt="5-10"></p>
<p>加载了 txt 之后，啥也不能干，必须要先汇编一下。<br>之后我们可以看到有许多原本灰暗的按钮亮了起来：</p>
<p><img src="5-11.png" alt="5-11"></p>
<ol>
<li>寄存器单元，在 31 条指令中，有 29 条指令（除开 j 和 jal）都和 寄存器 有关，所以这非常重要。这是检查正误最快的手段。</li>
<li>数据段，可以看到的确是从 0x1001_0000 开始的，也很重要。</li>
<li>代码段，的确是从 0x0040_0000 开始的，很重要很重要。</li>
<li>多步/单步调试按钮，顾名思义，自己试试。</li>
<li>导出按钮。</li>
</ol>
<p>着重说下导出按钮：</p>
<p><img src="5-12.png" alt="5-12"></p>
<p>没啥可说的，点了之后就会问导出的格式，这里咱们选择 16 进制格式，他并不会给出一个 16 进制文件（x），这个意思其实是以 16 进制格式导出指令。</p>
<p><img src="5-13.png" alt="5-13"></p>
<p>先以无格式保存。</p>
<p><img src="5-14.png" alt="5-14"></p>
<p>点击刚才保存的文件，这里我给出了一个真正的 coe 文件，我们可以发现，差的仅仅只是前两行，那么缝缝补补，就可以把导出的文件变成 coe 文件了。<br>并且这样生成的 coe 文件同样是可以给 IP 核替换的。</p>
<h4 id="4-比对工具"><a href="#4-比对工具" class="headerlink" title="4. 比对工具"></a>4. 比对工具</h4><p>我是拿眼睛比对的，效率还蛮高的。</p>
<h3 id="三、指令分析"><a href="#三、指令分析" class="headerlink" title="三、指令分析"></a>三、指令分析</h3><p>其实工具先学会用了并不影响进度，真要开始写，还得是好好分析分析指令。<br>一共就 31 条，也不多。</p>
<p>命令总共被分为 3 大类，分别是 R，I，J。</p>
<ul>
<li>R 我觉得就是和寄存器有很大关联的，两个操作数都是寄存器。</li>
<li>I 就是其中有个立即数。</li>
<li>J 指令甚至没有那么多操作数，跳转用。</li>
</ul>
<p><img src="5-15.png" alt="5-15"></p>
<p>下面对每个指令都看一下：</p>
<h4 id="1-add"><a href="#1-add" class="headerlink" title="1. add"></a>1. add</h4><p><img src="add.jpg" alt="add"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PC -&gt; IMEM</span><br><span class="line">PC + 4 -&gt; NPC</span><br><span class="line">NPC -&gt; PC</span><br><span class="line">Rs -&gt; A</span><br><span class="line">Rt -&gt; B</span><br><span class="line">RES -&gt; Rd</span><br></pre></td></tr></table></figure>
<p>其实与之类似的还有 <strong>addu/sub/subu/and/or/xor/nor</strong>，也就是说这 8 条指令只有运算器控制信号不同，除此之外基本完全一致。因此下只放图，暂不赘述。<br>至于究竟是 PC 传入 IMEM，还是 PC+4 的 NPC 传入 IMEM，其实是 PC，因为 NPC 中已经是下一个指令的地址了，但是这里看电路的话看不太出来执行的顺序。</p>
<p>其实这就是 verilog 和咱们之前学过的程序设计语言（学过的程度）的区别了吧，很多语句都可以并行执行，这提供了便利，但是不得不说也造成了 debug 时的困难。</p>
<h4 id="2-addu"><a href="#2-addu" class="headerlink" title="2. addu"></a>2. addu</h4><p><img src="addu.jpg" alt="addu"></p>
<h4 id="3-sub"><a href="#3-sub" class="headerlink" title="3. sub"></a>3. sub</h4><p><img src="sub.jpg" alt="sub"></p>
<h4 id="4-subu"><a href="#4-subu" class="headerlink" title="4. subu"></a>4. subu</h4><p><img src="subu.jpg" alt="subu"></p>
<h4 id="5-and"><a href="#5-and" class="headerlink" title="5. and"></a>5. and</h4><p><img src="and.jpg" alt="and"></p>
<h4 id="6-or"><a href="#6-or" class="headerlink" title="6. or"></a>6. or</h4><p><img src="or.jpg" alt="or"></p>
<h4 id="7-xor"><a href="#7-xor" class="headerlink" title="7. xor"></a>7. xor</h4><p><img src="xor.jpg" alt="xor"></p>
<h4 id="8-nor"><a href="#8-nor" class="headerlink" title="8. nor"></a>8. nor</h4><p><img src="nor.jpg" alt="nor"></p>
<h4 id="9-slt"><a href="#9-slt" class="headerlink" title="9. slt"></a>9. slt</h4><p>这个指令就和前面的不一样了，语义是给出大的一方。<br><strong>前者小于后者返回 1，前者大于后者返回 0。</strong><br>作为运算器，我认为面对这个指令有两种处理方法：</p>
<ol>
<li>这是一条可以用之前的指令实现的指令，比如配合 sub，将操作数二者做差，就可以得到对应的值；</li>
<li>这是一条新指令，需要用一个独特的 slt 控制信号来对应。</li>
</ol>
<p>我选择的是第二种，因为个人认为 slt 也算是一种运算指令，可以用 alu 实现。<br>具体的实现可以有两种方式：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code code code</span></span><br><span class="line">SLT: R &lt;= (A &lt; B);</span><br><span class="line"><span class="keyword">assign</span> sign = (ALUC == SLT) ? R[<span class="number">0</span>] : <span class="number">1'b0</span>;</span><br><span class="line"><span class="comment">// else</span></span><br><span class="line">SLT: R &lt;= A - B;</span><br><span class="line"><span class="keyword">assign</span> sign = ...;</span><br><span class="line"><span class="comment">// code code code</span></span><br></pre></td></tr></table></figure>
<p><img src="slt.jpg" alt="slt"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PC -&gt; IMEM</span><br><span class="line">PC + 4 -&gt; NPC</span><br><span class="line">NPC -&gt; PC</span><br><span class="line"></span><br><span class="line">Rs -&gt; A</span><br><span class="line">Rt -&gt; B # 懒得改了，这里少画了一根线</span><br><span class="line">SF -&gt; EXT1</span><br><span class="line">EXT1_out -&gt; Rd</span><br></pre></td></tr></table></figure>
<p>由于 alu 的 <code>Rd / Rs / Rt</code> 都是 32 位，所以需要 <strong>无符号扩展部件</strong>，把 sign flag 扩展到 32 位。这里的话，就将前面所说的 1 和 0，转化为了 SF 输出。</p>
<h4 id="10-sltu"><a href="#10-sltu" class="headerlink" title="10. sltu"></a>10. sltu</h4><p><img src="sltu.jpg" alt="sltu"></p>
<p>sltu 和 slt 看似及其类似，但是对于相同的输入却可能产生不同的输出。<br>此处举一个极端情况，这也是我 CPU31 在通过 simulation txt 文件前的最后一个 bug：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addi $3, $0, 0x7fff0000</span><br><span class="line">addi $2, $0, 0x8fff0000</span><br><span class="line"></span><br><span class="line">slt $4, $3, $2</span><br><span class="line">sltu $5, $3, $2</span><br></pre></td></tr></table></figure>
<p>（<strong>注：在这里使用 3 号和 4 号寄存器，并非 1 号寄存器是有原因的</strong>，1 号寄存器可能由于指令分解而被 <strong>占用</strong>，导致结果非预期值，见下图</p>
<p><img src="5-27.png" alt="5-27"></p>
<p>一个 addi 指令被拆解为 3 条指令执行，使用了 $1($at)，实际上 <strong>一号寄存器</strong> 最好不要乱用，毕竟从 $2 开始，才算是 $v0 啊。</p>
<p><strong>再注：如果上述指令无法执行，显示立即数超出范围类似的 Error，那么需要检查：</strong></p>
<p><img src="5-28.png" alt="5-28"></p>
<p>这个需要勾选，不然不允许扩展处理（也就是拆分指令之后，我们看到 Mars 对此 addi 语句的处理）。</p>
<p>）</p>
<h4 id="11-sll"><a href="#11-sll" class="headerlink" title="11. sll"></a>11. sll</h4><p><img src="sll.jpg" alt="sll"></p>
<p>这是移位指令，sll 是左移位，移动的位数由立即数决定，这个指令的 Format 和其他 R 型指令不同，需要格外注意：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PC -&gt; IMEM</span><br><span class="line">PC + 4 -&gt; NPC</span><br><span class="line">NPC -&gt; PC</span><br><span class="line"></span><br><span class="line">IMEM[10:6] -&gt; EXT5</span><br><span class="line">EXT5_out -&gt; A # 这里又画错了，应该是 A，看看指令表就知道了</span><br><span class="line"></span><br><span class="line">Rt -&gt; B # 这里应该是 Rt 传给 B 的，画成 Rs 传给 A 了</span><br><span class="line">Res -&gt; Rd</span><br></pre></td></tr></table></figure>
<p>可见这个指令相较前面的指令来说，要复杂一些，原因就是这个指令在 <strong>指令中出现了 shamt</strong>，从而使得需要对立即数进行操作，这个操作包括指令的截取，无符号扩展。<br>这也是在数据通路中第一次把 IMEM 和 ALU 这边打通，打通的本质，就是 指令中 出现了需要 ALU 直接或间接处理的信息。</p>
<h4 id="12-srl"><a href="#12-srl" class="headerlink" title="12. srl"></a>12. srl</h4><p>同上，应该都画错了相同的地方：</p>
<p><img src="srl.jpg" alt="srl"></p>
<h4 id="13-sra"><a href="#13-sra" class="headerlink" title="13. sra"></a>13. sra</h4><p><img src="sra.jpg" alt="sra"></p>
<p>只不过需要注意的是：<br>sra 是算术右移，需要补齐符号位。<br>比如 0x7ff0_0000，右移16位之后，是：<strong>0x0000_7ff0</strong>；<br>而如果是 0xf7ff_0010，算术右移16位之后，则是：<strong>0xffff_f7ff</strong>。</p>
<p>在写 verilog 的时候，我们声明变量通常喜欢：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] Res, A, B;</span><br></pre></td></tr></table></figure>
<p>但实际上，这也创建的寄存器变量只是 <strong>无符号</strong> 类型的。<br>在面对一些对 <strong>符号</strong> 有区别的运算，比如 <strong>&gt;&gt;&gt;</strong> 时，会有不同的结果：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] Res, A, B;</span><br><span class="line"><span class="keyword">reg</span> <span class="keyword">signed</span> [<span class="number">31</span>:<span class="number">0</span>] signA, signB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(ALUC)</span><br><span class="line">        SRA_fake: Res &lt;= A &gt;&gt;&gt; B;</span><br><span class="line">        SRA_true: Res &lt;= signA &gt;&gt;&gt; signB;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>上面的执行结果不同。<br>如果是 0xf7ff_0010，算术右移16位之后有不同的结果。</p>
<p><code>SRA_fake</code> 的结果是：<strong>0x0000_f7ff</strong>。<br><code>SRA_true</code> 的结果是：<strong>0xffff_f7ff</strong>。</p>
<p>因为一是无符号，一是有符号。</p>
<h4 id="14-sllv"><a href="#14-sllv" class="headerlink" title="14. sllv"></a>14. sllv</h4><p><img src="sllv.jpg" alt="sllv"></p>
<p>这个移位表示两个操作数均从 <strong>寄存器</strong> 中出。<br>并且这次的图是没有画错的。不过有几点还是要说明一下：</p>
<ol>
<li>EXT5 并不是必要的，因为 Rs 传出来的就是 32bits 数据，而 A 又需要接受 32bits 数据，实际上这个 EXT5 接受的只是 Rs 的低 5 位，这个可以通过 verilog 的语法轻松实现。</li>
<li>Rt 却不需要扩展，因为在这里，Rt 是被移位的数字，而 Rs 给出的是 <strong>移位数</strong>。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PC -&gt; IMEM</span><br><span class="line">PC + 4 -&gt; NPC</span><br><span class="line">NPC -&gt; PC</span><br><span class="line"></span><br><span class="line">Rs[4:0] -&gt; EXT5</span><br><span class="line">EXT5_out -&gt; A</span><br><span class="line">Rt -&gt; B</span><br><span class="line">Res -&gt; Rd</span><br></pre></td></tr></table></figure>
<h4 id="15-srlv"><a href="#15-srlv" class="headerlink" title="15. srlv"></a>15. srlv</h4><p><img src="srlv.jpg" alt="srlv"></p>
<p>同理，如上。</p>
<h4 id="16-srav"><a href="#16-srav" class="headerlink" title="16. srav"></a>16. srav</h4><p><img src="srav.jpg" alt="srav"></p>
<h4 id="17-jr"><a href="#17-jr" class="headerlink" title="17. jr"></a>17. jr</h4><p><img src="jr.jpg" alt="jr"></p>
<p>这个指令是 R 型指令中最为特殊的一个了，因为它也有跳转的功能。<br>并且这是从开始到现在，第一次见到的：</p>
<ol>
<li>没有使用 alu 的指令；</li>
<li>NPC 不直接传入 PC 的指令。</li>
</ol>
<p>读了指令表就知道，这个指令的意思是根据寄存器中的数据跳转 PC。<br>其实根本不应该把 NPC 画出来，因为画出来了对这条指令没有什么太大影响，不过这方便了后面的叙述。</p>
<p>上面的那些指令都是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NPC -&gt; PC</span><br></pre></td></tr></table></figure>
<p>也就意味着 NPC 直接传到了 PC，可是这里需要 Regfile 里面寄存器的值传给 PC，这就是两种情况了。<br>对于多种情况，自然需要多路选择器来 <strong>根据指令的种类选择值来赋</strong>。</p>
<p>于是有了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PC -&gt; IMEM</span><br><span class="line">Rs -&gt; MUX</span><br><span class="line">MUX_out -&gt; PC</span><br><span class="line"></span><br><span class="line"># 下面是无关的操作</span><br><span class="line">PC + 4 -&gt; NPC</span><br><span class="line">NPC -&gt; MUX</span><br></pre></td></tr></table></figure>
<p>至此，R 型指令 17 条结束。</p>
<h4 id="18-addi"><a href="#18-addi" class="headerlink" title="18. addi"></a>18. addi</h4><p><img src="addi.jpg" alt="addi"></p>
<p>其实也没啥可说的。<br>和上面的 sll 类似，从 IMEM 中读取了一段数据作为操作数给了 ALU。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PC -&gt; IMEM</span><br><span class="line">PC + 4 -&gt; NPC</span><br><span class="line">NPC -&gt; PC</span><br><span class="line"></span><br><span class="line">IMEM[15:0] -&gt; EXT16</span><br><span class="line">EXT16_out -&gt; B</span><br><span class="line">Rs -&gt; A</span><br><span class="line">Res -&gt; Rd</span><br></pre></td></tr></table></figure>
<p>但需要注意，这里的 EXT16 可是 <strong>有符号扩展</strong>。<br>在 I 型指令中，<strong>addi/addiu/slti/sltiu</strong> 都是有符号扩展，其余为 <strong>无符号扩展</strong>。</p>
<p>这里需要额外注意一点：<br>看似数据通路图中并没有提及 Rt，但通过查看指令表，可以发现 Rt 的的确确还在发挥着它的作用。<br>在 addi 以及其他类似指令，比如 slti 中，Rt 就 <strong>类似于</strong> 之前指令的 Rd。</p>
<p>这么说起来可能让人感到困惑，一个比较简单地，能够理解的方式就是写汇编：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addi $4, $1, 0xffff8000</span><br></pre></td></tr></table></figure>
<p>（此指令在文件 _2_addi.txt 的第 6 行，对应 PC 0x00400014）<br>这个指令对应着的十六进制表示为：<strong>0x2024ffff</strong>。<br>这样不是很好看，写成二进制形式：001000 00001 00100 1111111111111111。</p>
<ol>
<li>其中第一段的 001000 就是 <strong>op</strong>，代表 addi 这个指令；</li>
<li>第二段的 00001 是 1，表示 1 号寄存器。然而这个在指令中却是 Rs 的段；</li>
<li>第三段的 00100 是 4，表示 4 号寄存器。然而这个在指令中却是 Rt 的段。</li>
</ol>
<p>由此不难看出，上面的这段汇编代码，是用人类比较好理解的方式给出的。但是 mips 汇编和对应的机器码或许并不一定是 <strong>一一对应位置</strong> 的。<br>但是 add 指令就不是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add $11, $11, $3</span><br></pre></td></tr></table></figure>
<p>（此指令在文件 _2_add.txt 的第 82 行，对应 PC 0x00400110）<br>其十六进制表示为：<strong>0x1635820</strong>。<br>我们写出对应的二进制形式：000000 01011 00011 01011 00000 100000<br>明显看出 Rs 对应的是 11，Rt 对应的是 3，Rd 位对应的也是 11。<br>可见这个不仅仅是汇编码，就连机器码都符合人类理解。</p>
<h4 id="19-addiu"><a href="#19-addiu" class="headerlink" title="19. addiu"></a>19. addiu</h4><p>与上面类似。</p>
<p><img src="addiu.jpg" alt="addiu"></p>
<h4 id="20-andi"><a href="#20-andi" class="headerlink" title="20. andi"></a>20. andi</h4><p><img src="andi.jpg" alt="andi"></p>
<p>这个扩展就是无符号的。想想就明白。</p>
<h4 id="21-ori"><a href="#21-ori" class="headerlink" title="21. ori"></a>21. ori</h4><p><img src="ori.jpg" alt="ori"></p>
<h4 id="22-xori"><a href="#22-xori" class="headerlink" title="22. xori"></a>22. xori</h4><p><img src="xori.jpg" alt="xori"></p>
<p>至此，31 条指令已过去大半。</p>
<h4 id="23-lw"><a href="#23-lw" class="headerlink" title="23. lw"></a>23. lw</h4><p><img src="lw.jpg" alt="lw"></p>
<p>这也算是一条新指令，它新在：</p>
<ol>
<li>将<strong>数据存储器 DMEM</strong>加入图中；</li>
<li>这是第一个使用了运算器，但是可以使用之前的 ALUC 替代的指令。（这里用的是 add）</li>
</ol>
<p>因为 lw 指令要的是将 Rs 和 传过来的 EXT16_out 加和。<br>通过加和后的 Res 传入 DMEM 的 addr，读取数据。<br>这个指令比之前的都要复杂，可以说是最为复杂的一个指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PC -&gt; IMEM</span><br><span class="line">PC + 4 -&gt; NPC</span><br><span class="line">NPC -&gt; PC</span><br><span class="line"></span><br><span class="line">IMEM[15:0] -&gt; EXT16</span><br><span class="line">EXT16_out -&gt; B</span><br><span class="line">Rs -&gt; A</span><br><span class="line">Res -&gt; DMEM_addr</span><br><span class="line">DMEM_out -&gt; Rd</span><br></pre></td></tr></table></figure>
<h4 id="24-sw"><a href="#24-sw" class="headerlink" title="24. sw"></a>24. sw</h4><p>与 lw 其实没多少差别，主要是 Rt 作为写入数据存储器的数据，直接给到了 DMEM 中：</p>
<p><img src="sw.jpg" alt="sw"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PC -&gt; IMEM</span><br><span class="line">PC + 4 -&gt; NPC</span><br><span class="line">NPC -&gt; PC</span><br><span class="line"></span><br><span class="line">IMEM[15:0] -&gt; EXT16</span><br><span class="line">EXT16_out -&gt; B</span><br><span class="line">Rs -&gt; A</span><br><span class="line">Rt -&gt; DMEM</span><br><span class="line">Res -&gt; DMEM_addr</span><br></pre></td></tr></table></figure>
<h4 id="25-beq"><a href="#25-beq" class="headerlink" title="25. beq"></a>25. beq</h4><p>这个是原本的 8 条指令中有的，不想多说了。也没啥需要注意的。</p>
<p><img src="beq.jpg" alt="beq"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PC -&gt; IMEM</span><br><span class="line">PC + 4 -&gt; NPC</span><br><span class="line">NPC -&gt; MUX</span><br><span class="line"></span><br><span class="line">IMEM[15:0] || 02 -&gt; EXT18</span><br><span class="line">EXT18_out -&gt; ADD</span><br><span class="line">NPC -&gt; ADD</span><br><span class="line">ADD_out -&gt; MUX</span><br><span class="line"></span><br><span class="line">MUX_out -&gt; PC</span><br><span class="line"></span><br><span class="line">Rs -&gt; A</span><br><span class="line">Rt -&gt; B</span><br></pre></td></tr></table></figure>
<p>哎，还是得说下，这个指令在处理 PC 时尤为复杂，其判断符号也是 alu 给出的。<br>通过 A 和 B 的相等判断，取出的 ZF(zero flag) 会传入某个多路选择器，从而完成 beq 在指令流程中呈现的分支结构。</p>
<h4 id="26-bne"><a href="#26-bne" class="headerlink" title="26. bne"></a>26. bne</h4><p><img src="bne.jpg" alt="bne"></p>
<p>同理，bne 是一样的。</p>
<h4 id="27-slti"><a href="#27-slti" class="headerlink" title="27. slti"></a>27. slti</h4><p>上面说了，这个指令的 ext 是有符号的。</p>
<p><img src="slti.jpg" alt="slti"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PC -&gt; IMEM</span><br><span class="line">PC + 4 -&gt; NPC</span><br><span class="line">NPC -&gt; PC</span><br><span class="line"></span><br><span class="line">IMEM[15:0] -&gt; EXT16</span><br><span class="line">EXT16_out -&gt; B</span><br><span class="line">Rs -&gt; A</span><br><span class="line">CF -&gt; EXT32</span><br><span class="line">EXT32_out -&gt; Rd</span><br></pre></td></tr></table></figure>
<p>然而实际编码当中，也不需要那么麻烦的符号扩展部件，用 verilog 的拼接语法好好写就行了。<br>除此之外，还想说明一点。</p>
<p>在 Mars 中，并不是所有的寄存器初始值都为 0。<br>比如 <strong>第 28 号寄存器 $gp 与第 29 号寄存器 $sp</strong>。<br>$gp，顾名思义，是 <code>global pointer</code>，$sp 则是 <code>stack pointer</code>。<br>它们都是比较关键的寄存器，按道理来说，我认为测试时不应该动这两个寄存器的值。</p>
<p>也正是因为咱们的要求中没有提及这两个寄存器，然而 Mars 却考虑了。<br>因此，会产生些许问题：</p>
<ol>
<li>运行中断</li>
<li>结果不一</li>
</ol>
<p>第一个的意思是，在某些测试用的 txt 文件中的汇编代码，<strong>并不能执行到最后一句话！</strong>（比如 slti，sltiu 等等）<br>第二点的意思是，由于 Mars 对 gp 和 sp 两寄存器的初始化，外加某些测试文件并没有在 <strong>进行测试前重新置位所有寄存器</strong>，导致有些运算本想以 0 为操作数，却将 sp 的默认值 0x7fffeffc（或其他栈指针初始设置）作为操作数。导致结果不一。（比如 xori 等等）</p>
<p>因此为了和仿真结果相同。<br>我们可以擅自在这些问题文件前加几句话：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addi $28, $0, 0x0000</span><br><span class="line">addi $29, $0, 0x0000</span><br></pre></td></tr></table></figure>
<p>这样，文件可以正常运行并与仿真结果比对。</p>
<h4 id="28-sltiu"><a href="#28-sltiu" class="headerlink" title="28. sltiu"></a>28. sltiu</h4><p>与上相同。</p>
<p><img src="sltiu.jpg" alt="sltiu"></p>
<h4 id="29-lui"><a href="#29-lui" class="headerlink" title="29. lui"></a>29. lui</h4><p>这是个简单的指令，要做的只是腾空低 16 位，具体流程可见指令表。<br>使用 verilog 的拼接方法，就可以做到：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alu code</span></span><br><span class="line">    LUI: Res &lt;= &#123;B[<span class="number">15</span>:<span class="number">0</span>], <span class="number">16'b0</span>&#125;;</span><br><span class="line"><span class="comment">// alu code</span></span><br></pre></td></tr></table></figure>
<p><img src="lui.jpg" alt="lui"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PC -&gt; IMEM</span><br><span class="line">PC + 4 -&gt; NPC</span><br><span class="line">NPC -&gt; PC</span><br><span class="line"></span><br><span class="line">IMEM[15:0] -&gt; EXT16</span><br><span class="line">EXT16_out -&gt; B</span><br><span class="line">Res -&gt; Rd</span><br></pre></td></tr></table></figure>
<p>那么至此， I 型指令也结束了，剩下的是两条 J 型指令。</p>
<h4 id="30-j"><a href="#30-j" class="headerlink" title="30. j"></a>30. j</h4><p><img src="j.jpg" alt="j"></p>
<p>这个指令不需要用到 alu、regfile、dmem 等部件，非常的简洁。<br>同时，它的出现也代表着，选择器的可选项又多了一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PC -&gt; IMEM</span><br><span class="line">PC[31:28] -&gt; ||_A</span><br><span class="line">IMEM[25,0] || 02 -&gt; ||_B</span><br><span class="line">||_out -&gt; MUX</span><br><span class="line"></span><br><span class="line">PC + 4 -&gt; NPC</span><br><span class="line">NPC -&gt; MUX</span><br><span class="line"></span><br><span class="line">MUX_out -&gt; PC</span><br></pre></td></tr></table></figure>
<p>这里需要解释几个符号，它们都是比较常用的符号，并不是我故意这么写的。</p>
<p><code>IMEM[25,0] || 02</code> 中，<code>||</code> 指的是 <strong>左移</strong>。<br>这句话意思就是 IMEM 的从 0 到 25 位截取下来，并左移 2 位，变成 28 位长度的数据。<br>也可以理解成 <strong>原本 26 bits 长的数据 拼接了 2 bits 的 0</strong>。</p>
<p>而较大的那个 <code>||</code> 则是拼接部件，将传入的 A 和 B，拼接为 AB。<br>那么这里实际上最终结果就是：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat_out &lt;= &#123; PC[<span class="number">31</span>:<span class="number">28</span>], IMEM[<span class="number">25</span>:<span class="number">0</span>], <span class="number">2'b0</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>可以这么理解，但是编码不一定这么实现。<br>至于为什么要 MUX，其实 j 是强行跳转，MUX 那里写着只是代表 <strong>还有这条指令之外的更新 PC 的方法</strong>。<br>并不意味着本指令需要 <code>NPC -&gt; PC</code> 这种手段。</p>
<h4 id="31-jal"><a href="#31-jal" class="headerlink" title="31. jal"></a>31. jal</h4><p>最后一条指令。</p>
<p><img src="jal.jpg" alt="jal"></p>
<p>其实并不复杂。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PC -&gt; IMEM</span><br><span class="line">PC[31:28] -&gt; ||_A</span><br><span class="line">IMEM[25,0] || 02 -&gt; ||_B</span><br><span class="line"></span><br><span class="line">||_out -&gt; MUX</span><br><span class="line">PC + 4 -&gt; NPC</span><br><span class="line">NPC -&gt; MUX</span><br><span class="line">MUX_out -&gt; PC</span><br><span class="line"></span><br><span class="line">PC -&gt; ADD</span><br><span class="line">8 -&gt; ADD</span><br><span class="line">ADD_out -&gt; Rd</span><br></pre></td></tr></table></figure>
<p>这个指令并不复杂，只是为了实现这个指令，未来的控制信号多了点。<br>相信经过了前面 30 条指令的考验，这条指令并不难理解。</p>
<h4 id="32-CPU31"><a href="#32-CPU31" class="headerlink" title="32. CPU31"></a>32. CPU31</h4><p>其实上面的有些数据通路画错了，特别是 ALU 的 ALUC，有很多指令，比如 addi 和 add，他们是共用一个 ALUC 的，只是我一开始理解不够深刻，所以画错了，并且还保存了起来。之后想要再做修改实在是困难麻烦。<br>那么我们在此基础之上，通过适当组合，可以得到总的数据通路图：</p>
<p><img src="CPU31.jpg" alt="cpu31"></p>
<p>组合它们的这个过程并不难，花费时间最多的地方在于调整每个箭头的位置……</p>
<h3 id="四、控制信号"><a href="#四、控制信号" class="headerlink" title="四、控制信号"></a>四、控制信号</h3><p>经过刚才的拼接，CPU31 的通路图已经得到了。<br>那么需要做些说明：</p>
<ol>
<li>我采取的并非更多选择的多路选择器，每个多路选择器仅仅是 2 个选项而已。</li>
<li>图中某些部件并未实现，比如 NPC / || / MUX 等。</li>
<li>通路间并非仅仅如图所示，还有其他复杂的细节没有画出，因为后面调整起来太麻烦了。</li>
<li>整个作图使用 Processon，非常的好用，非常的好看。<a href="https://www.processon.com/" target="_blank" rel="noopener">Processon 官网</a></li>
</ol>
<p>既然我每次选择都是 2 选 1，也就意味着一旦某个信号包括 n 个可能输入，我就要使用 n-1 个多路选择器实现。<br>这是很麻烦的一件事。<br>不过还好 2 选 1 的多路选择器，一个 ?: 语句就可以搞定。</p>
<p>但是我们要看到，如此多的选择器，必定要许多<strong>控制信号</strong>，控制信号的正误，决定了整个 CPU31 的成败。<br>根据通路图，我自然得知如下的控制信号表：</p>
<p><img src="5-16.png" alt="5-16"></p>
<p>根据这个信号表，我们可以实现 CPU 模块的控制信号部分。</p>
<h3 id="五、从开始到现在"><a href="#五、从开始到现在" class="headerlink" title="五、从开始到现在"></a>五、从开始到现在</h3><p>从开始到现在，看了 IP 核的配置，调试工具的使用，指令流程，数据通路，控制信号。<br>准备得如此充分，我们肯定可以实现些什么了。</p>
<ol>
<li>有了配置 IP 核的能力，我们可以先把 IMEM 写出来；</li>
<li>对各指令流程的了解，我们可以写出 ALU；</li>
<li>有了控制信号表，我们可以写出 Controller；</li>
<li>介于对 Mars 的理解，我们得知 DMEM 和 Regfile 的大体模样（可见前图），我们可以写出 DMEM 和 Regfile。</li>
</ol>
<p>我们知道，机器的 CPU 由运算器、控制器、寄存器组成的。<br><strong>运算器</strong>就是 ALU，<strong>控制器</strong>就是我们的 Controller，<strong>寄存器</strong>是 Regfile。<br>除此之外，在哈佛结构中有两个存储器，分别是 <strong>指令存储器</strong> IMEM 和 <strong>数据存储器</strong> DMEM。</p>
<p>这么一看，好像 CPU 已经可以写的七七八八了。<br>事实也的确如此。</p>
<p>我们先假设已经写完了，看看真正的通路图：</p>
<p><img src="5-17.png" alt="5-17"></p>
<p>这是整个 CPU31 的 schematic。</p>
<p><img src="5-19.png" alt="5-19"></p>
<p>这是 CPU 模块，最左侧比较小的蓝色是 ALU，最右面比较大的是 Regfile，中间的一块蓝色是一个特殊的模块，叫做 PCreg，专门存储 PC 这个数据。<br>中间的很多黄色，可以理解为多路选择器的一种体现。</p>
<p><img src="5-20.png" alt="5-20"></p>
<p>这是一个重要的模块，叫做 PCreg，这张图是其内部的样子。我认为 PCreg 就像是一颗心脏，它的持续变化才使得整个 CPU 持续不断地执行指令。</p>
<p><img src="5-22.png" alt="5-22"></p>
<p>这个是 ALU，比较的小巧，因为其中没有使用时序逻辑，完完全全都是<strong>组合逻辑</strong>，一旦给定输入，立刻给出输出。</p>
<p><img src="5-21.png" alt="5-21"></p>
<p>相比之下，Regfile 就要庞大许多，虽然也是 32 个寄存器，或许是加了复位功能吧，显得比较乱，很多数据比如 ALU，PC，以及图中显示的 DMEM 都会和 Regfile 有关。</p>
<p><img src="5-24.png" alt="5-24"></p>
<p>除 CPU 核心外，还有 DMEM，这里实现的也比较小巧。<br>中间有 32 个存储单元。</p>
<p><img src="5-23.png" alt="5-23"></p>
<p>这个最外面的方框圈中的是 IMEM，由于用了 IP 核，总归要大一些。</p>
<p>总而言之，就我来说，用到了这些源文件：</p>
<p><img src="5-25.png" alt="5-25"></p>
<h3 id="六、从现在到开始"><a href="#六、从现在到开始" class="headerlink" title="六、从现在到开始"></a>六、从现在到开始</h3><p>准备工作做好了，也对 CPU31 半成品长什么样子有了一个了解，现在就可以开始编码了。</p>
<h4 id="1-IMEM"><a href="#1-IMEM" class="headerlink" title="1. IMEM"></a>1. IMEM</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IMEM.v</span></span><br><span class="line"><span class="keyword">module</span> IMEM(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">10</span>:<span class="number">0</span>] addr,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] instr</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    dist_mem_gen_0 instr_mem(</span><br><span class="line">        <span class="variable">.a</span>(addr),</span><br><span class="line">        <span class="variable">.spo</span>(instr)</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>就是调个 IP 核，也没啥其他要说的……<br>给定了 addr，就会立刻返回对应的 instruction。<br>不信的话，可以写个 testbench 试一试：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test_imem.v</span></span><br><span class="line"><span class="keyword">module</span> test_imem(</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">10</span>:<span class="number">0</span>] a;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] spo;</span><br><span class="line">    IMEM imem(</span><br><span class="line">        <span class="variable">.addr</span>(a),</span><br><span class="line">        <span class="variable">.instr</span>(spo)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        a = <span class="number">11'b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">        #<span class="number">20</span> a = a + <span class="number">1'b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h4 id="2-DMEM"><a href="#2-DMEM" class="headerlink" title="2. DMEM"></a>2. DMEM</h4><p>至于 DMEM，要说的还是有几点。<br>首先 DMEM，我个人认为不需要考虑 reset 这件事。<br>其次，对于寄存器堆 Regfile，其有 <strong>零寄存器</strong> 的概念，第一个寄存器的值不容改变。<br>但是对于 DMEM，可没有 <strong>零内存</strong> 的概念，具体可以到 Mars 中一试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add $0, $0, 0x10100000</span><br><span class="line">add $1, $0, 0x10100000</span><br><span class="line">sw $1, 0($1)</span><br><span class="line">sw $0, 0($1)</span><br><span class="line">sw $1, 0($0)</span><br></pre></td></tr></table></figure>
<p>程序会在最后一句话执行后报错退出。因为 零寄存器 始终为 0。<br>而 sw 给出的偏移地址却为 0，不满足 Mips 体系架构下对 数据段首地址 的定义要求。</p>
<p>再次，在这里我使用的是 posedge clk，这个并不固定，应随着自己的设计变化而变化，并非一成不变。<br>最后，D_mem 的声明是 verilog 的语法，向量数组取值时要格外注意，应遵守 verilog 的相关文档或标准。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> DMEM(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> ena,</span><br><span class="line">    <span class="keyword">input</span> DM_W,</span><br><span class="line">    <span class="keyword">input</span> DM_R,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">10</span>:<span class="number">0</span>] DM_addr,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] DM_wdata,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] DM_rdata</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] D_mem[<span class="number">0</span>:<span class="number">31</span>];</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (DM_W &amp;&amp; ena) <span class="keyword">begin</span></span><br><span class="line">            D_mem[DM_addr] &lt;= DM_wdata;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> DM_rdata = (DM_R &amp;&amp; ena) ? D_mem[DM_addr] : <span class="number">32'bz</span>;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>对于各个控制信号，ena 表示使能。<br>我的 DMEM 可以一直读，读是非时序逻辑的，而写需要时钟沿上升。</p>
<h4 id="3-ALU"><a href="#3-ALU" class="headerlink" title="3. ALU"></a>3. ALU</h4><p>ALU 这个上数字逻辑的时候已经写过了，不需要太注意。<br>值得一提的是，在上汇编时了解过，运算结果不仅仅是两个操作数执行某个指令后得到的输出，还包括一系列的标志位。<br>比如 nor 按位取反不改变标志位，有符号运算不改变 CF 等等规则。<br>这些规则，我一个都没有写。</p>
<p>并且标志位也只给出了 ZF, SF, CF, OF。（本来以为 OF 有用的，结果好像没用到，所以 OF 的赋值也是乱写的）</p>
<p>ALU 执行命令，需要三个东西：</p>
<ol>
<li>第一个操作数</li>
<li>第二个操作数</li>
<li>执行的指令类型</li>
</ol>
<p>操作数好说，传过来就行。<br>但是指令类型如何确定却是个问题。我们在 IMEM 中读到了指令，这个在 testbench 下可以直接看出来。<br>读到的指令分为几个部分，我们或许可以根据 func 和 op 来唯一表示指令类型。<br>或者直接用 instruction 中的 func 和 op 直接标识。<br>在这里，我重新编了一次码，对 ALU 中可能直接处理的运算做了重新编码。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ALU.v</span></span><br><span class="line"><span class="keyword">module</span> ALU(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] A,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] B,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] Res,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>] ALUC,</span><br><span class="line">    <span class="keyword">output</span> zero,  <span class="comment">// 0 is true, others are false</span></span><br><span class="line">    <span class="keyword">output</span> carry, <span class="comment">// unsigned cf</span></span><br><span class="line">    <span class="keyword">output</span> sign, <span class="comment">// 1 is false, 0 is true</span></span><br><span class="line">    <span class="keyword">output</span> overflow <span class="comment">// signed of</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">parameter</span> ADD = <span class="number">5'b00000</span>;</span><br><span class="line">    <span class="keyword">parameter</span> ADDU = <span class="number">5'b00001</span>;</span><br><span class="line">    <span class="keyword">parameter</span> SUB = <span class="number">5'b00010</span>;</span><br><span class="line">    <span class="keyword">parameter</span> SUBU = <span class="number">5'b00011</span>;</span><br><span class="line">    <span class="keyword">parameter</span> AND = <span class="number">5'b00100</span>;</span><br><span class="line">    <span class="keyword">parameter</span> OR = <span class="number">5'b00101</span>;</span><br><span class="line">    <span class="keyword">parameter</span> XOR = <span class="number">5'b00110</span>;</span><br><span class="line">    <span class="keyword">parameter</span> NOR = <span class="number">5'b00111</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">parameter</span> SLT = <span class="number">5'b01000</span>;</span><br><span class="line">    <span class="keyword">parameter</span> SLTU = <span class="number">5'b01001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">parameter</span> SLL = <span class="number">5'b01010</span>;</span><br><span class="line">    <span class="keyword">parameter</span> SRL = <span class="number">5'b01011</span>;</span><br><span class="line">    <span class="keyword">parameter</span> SRA = <span class="number">5'b01100</span>;</span><br><span class="line">    <span class="keyword">parameter</span> SLLV = <span class="number">5'b01101</span>;</span><br><span class="line">    <span class="keyword">parameter</span> SRLV = <span class="number">5'b01110</span>;</span><br><span class="line">    <span class="keyword">parameter</span> SRAV = <span class="number">5'b01111</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">parameter</span> LUI = <span class="number">5'b10000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> <span class="keyword">signed</span> [<span class="number">31</span>:<span class="number">0</span>] signA, signB;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">32</span>:<span class="number">0</span>] R;</span><br><span class="line">    <span class="keyword">reg</span> CF_open, OF_open, ZF_open, SF_open;</span><br><span class="line">    <span class="keyword">assign</span> signA = A;</span><br><span class="line">    <span class="keyword">assign</span> signB = B;</span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(ALUC)</span><br><span class="line">            ADD:    R &lt;= signA + signB;</span><br><span class="line">            ADDU:   R &lt;= A + B;</span><br><span class="line">            SUB:    R &lt;= signA - signB;</span><br><span class="line">            SUBU:   R &lt;= A - B;</span><br><span class="line">            AND:    R &lt;= A &amp; B;</span><br><span class="line">            OR:     R &lt;= A | B;</span><br><span class="line">            XOR:    R &lt;= A ^ B;</span><br><span class="line">            NOR:    R &lt;= ~(A | B);</span><br><span class="line"></span><br><span class="line">            SLT:    R &lt;= (signA - signB);</span><br><span class="line">            SLTU:   R &lt;= (A - B);</span><br><span class="line"></span><br><span class="line">            SLL:    R &lt;= B &lt;&lt; A;</span><br><span class="line">            SRL:    R &lt;= B &gt;&gt; A;</span><br><span class="line">            SRA:    R &lt;= signB &gt;&gt;&gt; signA;</span><br><span class="line">            SLLV:   R &lt;= B &lt;&lt; A[<span class="number">4</span>:<span class="number">0</span>];</span><br><span class="line">            SRLV:   R &lt;= B &gt;&gt; A[<span class="number">4</span>:<span class="number">0</span>];</span><br><span class="line">            SRAV:   R &lt;= signB &gt;&gt;&gt; signA[<span class="number">4</span>:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            LUI:    R &lt;= &#123;B[<span class="number">15</span>:<span class="number">0</span>], <span class="number">16'b0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">assign</span> Res = R[<span class="number">31</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">assign</span> zero = (R == <span class="number">32'b0</span>) ? <span class="number">1'b1</span> : <span class="number">1'b0</span>;</span><br><span class="line">    <span class="keyword">assign</span> carry = R[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">assign</span> overflow = R[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">assign</span> sign = (ALUC == SLT ? (signA &lt; signB) : ((ALUC == SLTU) ? (A &lt; B) : <span class="number">1'b0</span>));</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>可能看起来不是那么令人放心，但是 ALU 就是完完全全的组合逻辑，没有时序逻辑在。<br>标志位乱写一点也是没关系的。</p>
<h4 id="4-Regfile"><a href="#4-Regfile" class="headerlink" title="4. Regfile"></a>4. Regfile</h4><p>刚才说了 Regfile 有 <strong>零寄存器</strong>。<br>零寄存器呢，设计出来是为了简化运算。有的时候经常会用到 0 来进行判断，进行运算。</p>
<p>比如 beq 指令。beq 指令在 mips 中实际上可以拆解为两步。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beq $2, 10, sec1</span><br></pre></td></tr></table></figure>
<p>会被拆解为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addi $1, $0, 0x0000000a # 这个是立即数 10 的十六进制表示</span><br><span class="line">beq $1, $2, 0x00000000 # 随便写的段地址</span><br></pre></td></tr></table></figure>
<p>可以看出在进行 寄存器数据 和 立即数 之间比较时，会将 <strong>立即数暂存到某个寄存器中</strong>。<br>而这个寄存器就是 $1, mips 中称为 $at，也算是个不能乱用的寄存器。<br>这里就是利用了 <strong>永为0</strong> 的零寄存器，对 addi 的一个操作数进行了填充。</p>
<p>因此 零寄存器 是不能修改为任何非零值的。<br>那么不妨在置位时置 0，之后写成不能修改。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RegFile.v</span></span><br><span class="line"><span class="keyword">module</span> RegFile(</span><br><span class="line">    <span class="keyword">input</span> RF_ena,</span><br><span class="line">    <span class="keyword">input</span> RF_rst,</span><br><span class="line">    <span class="keyword">input</span> RF_clk,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>] Rdc,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>] Rsc,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>] Rtc,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] Rd,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] Rs,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] Rt,</span><br><span class="line">    <span class="keyword">input</span> RF_W</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] registers[<span class="number">31</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> RF_clk <span class="keyword">or</span> <span class="keyword">posedge</span> RF_rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (RF_rst &amp; RF_ena) <span class="keyword">begin</span></span><br><span class="line">            registers[<span class="number">0</span>] &lt;= <span class="number">32'b0</span>;</span><br><span class="line">            registers[<span class="number">1</span>] &lt;= <span class="number">32'b0</span>;</span><br><span class="line">            registers[<span class="number">2</span>] &lt;= <span class="number">32'b0</span>;</span><br><span class="line">            registers[<span class="number">3</span>] &lt;= <span class="number">32'b0</span>;</span><br><span class="line">            registers[<span class="number">4</span>] &lt;= <span class="number">32'b0</span>;</span><br><span class="line">            registers[<span class="number">5</span>] &lt;= <span class="number">32'b0</span>;</span><br><span class="line">            registers[<span class="number">6</span>] &lt;= <span class="number">32'b0</span>;</span><br><span class="line">            registers[<span class="number">7</span>] &lt;= <span class="number">32'b0</span>;</span><br><span class="line">            registers[<span class="number">8</span>] &lt;= <span class="number">32'b0</span>;</span><br><span class="line">            registers[<span class="number">9</span>] &lt;= <span class="number">32'b0</span>;</span><br><span class="line">            registers[<span class="number">10</span>] &lt;= <span class="number">32'b0</span>;</span><br><span class="line">            registers[<span class="number">11</span>] &lt;= <span class="number">32'b0</span>;</span><br><span class="line">            registers[<span class="number">12</span>] &lt;= <span class="number">32'b0</span>;</span><br><span class="line">            registers[<span class="number">13</span>] &lt;= <span class="number">32'b0</span>;</span><br><span class="line">            registers[<span class="number">14</span>] &lt;= <span class="number">32'b0</span>;</span><br><span class="line">            registers[<span class="number">15</span>] &lt;= <span class="number">32'b0</span>;</span><br><span class="line">            registers[<span class="number">16</span>] &lt;= <span class="number">32'b0</span>;</span><br><span class="line">            registers[<span class="number">17</span>] &lt;= <span class="number">32'b0</span>;</span><br><span class="line">            registers[<span class="number">18</span>] &lt;= <span class="number">32'b0</span>;</span><br><span class="line">            registers[<span class="number">19</span>] &lt;= <span class="number">32'b0</span>;</span><br><span class="line">            registers[<span class="number">20</span>] &lt;= <span class="number">32'b0</span>;</span><br><span class="line">            registers[<span class="number">21</span>] &lt;= <span class="number">32'b0</span>;</span><br><span class="line">            registers[<span class="number">22</span>] &lt;= <span class="number">32'b0</span>;</span><br><span class="line">            registers[<span class="number">23</span>] &lt;= <span class="number">32'b0</span>;</span><br><span class="line">            registers[<span class="number">24</span>] &lt;= <span class="number">32'b0</span>;</span><br><span class="line">            registers[<span class="number">25</span>] &lt;= <span class="number">32'b0</span>;</span><br><span class="line">            registers[<span class="number">26</span>] &lt;= <span class="number">32'b0</span>;</span><br><span class="line">            registers[<span class="number">27</span>] &lt;= <span class="number">32'b0</span>;</span><br><span class="line">            registers[<span class="number">28</span>] &lt;= <span class="number">32'b0</span>;</span><br><span class="line">            registers[<span class="number">29</span>] &lt;= <span class="number">32'b0</span>;</span><br><span class="line">            registers[<span class="number">30</span>] &lt;= <span class="number">32'b0</span>;</span><br><span class="line">            registers[<span class="number">31</span>] &lt;= <span class="number">32'b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (RF_W == <span class="number">1'b1</span> &amp;&amp; RF_ena &amp;&amp; Rdc != <span class="number">5'b0</span>)</span><br><span class="line">                registers[Rdc] &lt;= Rd;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> Rs = RF_ena ? registers[Rsc] : <span class="number">32'bz</span>;</span><br><span class="line">    <span class="keyword">assign</span> Rt = RF_ena ? registers[Rtc] : <span class="number">32'bz</span>;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>有关向量数组的置位我也表示很抱歉，我不知道 verilog 还有哪些方便的语法可以同一时间完成这个操作了。</p>
<p>Regfile 中，Rs 和 Rt 为输出，Rd 为输入。<br>Rsc，Rtc，Rdc 分别代表读写地址。<br>除了对 Regfile 的测试之外，没有什么要注意的地方：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test_regfile.v</span></span><br><span class="line"><span class="keyword">module</span> test_regfile(</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">reg</span> ena, rst, clk, w;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>] rdc, rsc, rtc;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] rs, rt;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] rd;</span><br><span class="line"></span><br><span class="line">    RegFile rf(</span><br><span class="line">        <span class="variable">.RF_ena</span>(ena), <span class="variable">.RF_rst</span>(rst), <span class="variable">.RF_clk</span>(clk), <span class="variable">.RF_W</span>(w),</span><br><span class="line">        <span class="variable">.Rdc</span>(rdc), <span class="variable">.Rsc</span>(rsc), <span class="variable">.Rtc</span>(rtc),</span><br><span class="line">        <span class="variable">.Rd</span>(rd), <span class="variable">.Rs</span>(rs), <span class="variable">.Rt</span>(rt)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        ena = <span class="number">1'b1</span>;</span><br><span class="line">        rst = <span class="number">1'b1</span>;</span><br><span class="line">        clk = <span class="number">1'b1</span>;</span><br><span class="line">        w = <span class="number">1'b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">        #<span class="number">20</span> clk = !clk;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">5</span>:<span class="number">0</span>] cnt = <span class="number">5'b00000</span>;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] rdin = <span class="number">32'h0000_a2fe</span>;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>] rdo = <span class="number">5'b00000</span>;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>] rso = <span class="number">5'b00000</span>;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>] rto = <span class="number">5'b00111</span>;</span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (rst) rst &lt;= !rst;</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; <span class="number">12</span>) <span class="keyword">begin</span></span><br><span class="line">            rdc &lt;= rdo;</span><br><span class="line">            rd &lt;= rdin;</span><br><span class="line">            rdin &lt;= rdin + <span class="number">1</span>;</span><br><span class="line">            rdo &lt;= rdo + <span class="number">1</span>;</span><br><span class="line">            cnt &lt;= cnt + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cnt &gt; <span class="number">12</span> &amp;&amp; cnt &lt; <span class="number">24</span>) <span class="keyword">begin</span></span><br><span class="line">            w &lt;= <span class="number">0</span>;</span><br><span class="line">            rsc &lt;= rso;</span><br><span class="line">            rtc &lt;= rto;</span><br><span class="line">            rso &lt;= rso + <span class="number">1</span>;</span><br><span class="line">            rto &lt;= rto - <span class="number">1</span>;</span><br><span class="line">            cnt &lt;= cnt + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            cnt &lt;= cnt + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h4 id="5-PCreg"><a href="#5-PCreg" class="headerlink" title="5. PCreg"></a>5. PCreg</h4><p>为什么要把 PC 专门抽出来，可不可以不抽出来？<br>这当然是可以的。</p>
<p>PC 是取值的凭依，只要实现以下特性：</p>
<ol>
<li>每个时钟周期都修改更新；</li>
<li>遭遇 j/jal/jr 指令，将新地址写入 PC；</li>
<li>从第一条指令开始执行，直到最后一条指令；</li>
</ol>
<p>我觉得就没有问题。<br>这里把 PCreg 抽出来，主要是因为一开始想对 数据通路 中的每个单元都写一个模块。<br>后来发现太麻烦，就放弃了。但是 PCreg 却留了下来。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PcReg.v</span></span><br><span class="line"><span class="keyword">module</span> PcReg(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> rst,</span><br><span class="line">    <span class="keyword">input</span> ena,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] PR_in,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] PR_out</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] PcRegister;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">negedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (ena) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (rst) <span class="keyword">begin</span></span><br><span class="line">                PcRegister &lt;= <span class="number">32'h00400000</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                PcRegister &lt;= PR_in;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> PR_out = (ena &amp;&amp; !rst) ? PcRegister : <span class="number">32'hz</span>;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>写时序逻辑的时候要注意一些事情。<br>比如一个 always 块中最好只有一个 if-else_if-else 语句；<br>比如异步中 rst 的上升下降沿要统一；<br>比如最好使用 &lt;= 而不是 = 等等。</p>
<p>在这里，我设计的 PCreg 是 clk 下降沿时更新 <code>PCRegister</code> 的值。这一点不一定都是这样，主要看的是各自的设计。</p>
<p>为了实现自己想要的时序图，应该写一份专门的 testbench 来调试：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test_pcreg.v</span></span><br><span class="line"><span class="keyword">module</span> test_pcreg(</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> clk, rst, ena;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] in;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] out;</span><br><span class="line"></span><br><span class="line">    PcReg pcreg(</span><br><span class="line">        <span class="variable">.clk</span>(clk), <span class="variable">.rst</span>(rst), <span class="variable">.ena</span>(ena),</span><br><span class="line">        <span class="variable">.PR_in</span>(in), <span class="variable">.PR_out</span>(out)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        clk = <span class="number">1</span>;</span><br><span class="line">        rst = <span class="number">1</span>;</span><br><span class="line">        ena = <span class="number">1</span>;</span><br><span class="line">        in = <span class="number">32'b0</span>;</span><br><span class="line"></span><br><span class="line">        #<span class="number">20</span> rst = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">        #<span class="number">20</span> clk = !clk;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">5</span>:<span class="number">0</span>] cnt = <span class="number">6'b0</span>;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; <span class="number">12</span>) <span class="keyword">begin</span></span><br><span class="line">            in = in + <span class="number">1'b1</span>;</span><br><span class="line">            cnt = cnt + <span class="number">1'b1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cnt == <span class="number">12</span>) <span class="keyword">begin</span></span><br><span class="line">            in = in + <span class="number">1'b1</span>;</span><br><span class="line">            #<span class="number">10</span> in = in + <span class="number">1'b1</span>;</span><br><span class="line">            cnt = cnt + <span class="number">1'b1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            cnt = <span class="number">6'b0</span>;</span><br><span class="line">            in = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h4 id="6-CPU"><a href="#6-CPU" class="headerlink" title="6. CPU"></a>6. CPU</h4><p>有了这些模块，最后的步骤就是组装，将之前的 Regfile，ALU，PcReg 整合起来。<br>但是这里要注意的是，上述三个模块在运行时需要各种控制信号。</p>
<p>这里我没有给出控制信号模块的具体书写，因为 CPU 的控制信号模块较为关键，并且放置的位置见仁见智。</p>
<ul>
<li>我完全可以在 Regfile，ALU，PcReg 中生成控制信号并处理。</li>
<li>也可以在上述三个模块之外开辟一个 Controller 模块（就像下面这样做），来实现控制。</li>
<li>当然更可以直接将所有控制信号列出，写在 CPU31 这个大的模块中，而不抽象任何的 .v 文件。</li>
</ul>
<p>只有自己最了解，也最应该了解自己写的 CPU 的 Controller 部件。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CPU31.v</span></span><br><span class="line"><span class="keyword">module</span> CPU31(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> ena,</span><br><span class="line">    <span class="keyword">input</span> rst,</span><br><span class="line">    <span class="keyword">output</span> DM_ena,</span><br><span class="line">    <span class="keyword">output</span> DM_W,</span><br><span class="line">    <span class="keyword">output</span> DM_R,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] IM_inst,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] DM_rdata,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] DM_wdata,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] PC_out,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] ALU_out</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> ZF, SF, CF, OF;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">4</span>:<span class="number">0</span>] ALUC;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">9</span>:<span class="number">0</span>] MUXC;</span><br><span class="line">    <span class="keyword">wire</span> RF_R, RF_W;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] PC, NPC;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">4</span>:<span class="number">0</span>] Rdc, Rsc, Rtc;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] Rd, Rs, Rt, A, B, Res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] MUX_out[<span class="number">9</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] EXT_18_out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> NPC = PC + <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">assign</span> DM_ena = <span class="number">1'b1</span>;</span><br><span class="line">    <span class="keyword">assign</span> DM_wdata = Rt;</span><br><span class="line">    <span class="keyword">assign</span> PC_out = PC;</span><br><span class="line">    <span class="keyword">assign</span> ALU_out = Res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> MUX_out[<span class="number">0</span>] = ...;</span><br><span class="line">    <span class="keyword">assign</span> MUX_out[<span class="number">1</span>] = ...;</span><br><span class="line">    <span class="keyword">assign</span> MUX_out[<span class="number">2</span>] = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> MUX_out[<span class="number">3</span>] = ...;</span><br><span class="line">    <span class="keyword">assign</span> MUX_out[<span class="number">4</span>] = ...;</span><br><span class="line">    <span class="keyword">assign</span> MUX_out[<span class="number">5</span>] = ...;</span><br><span class="line">    <span class="keyword">assign</span> MUX_out[<span class="number">6</span>] = ...;</span><br><span class="line">    <span class="keyword">assign</span> MUX_out[<span class="number">7</span>] =...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> MUX_out[<span class="number">8</span>] = ...;</span><br><span class="line">    <span class="keyword">assign</span> MUX_out[<span class="number">9</span>] = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> EXT_18_out = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> Rd = ...;</span><br><span class="line">    <span class="keyword">assign</span> Rsc = ...;</span><br><span class="line">    <span class="keyword">assign</span> Rtc = ...;</span><br><span class="line">    <span class="keyword">assign</span> Rdc = ...;</span><br><span class="line"></span><br><span class="line">    RegFile Rf(</span><br><span class="line">        <span class="variable">.RF_ena</span>(ena),</span><br><span class="line">        <span class="variable">.RF_rst</span>(rst),</span><br><span class="line">        <span class="variable">.RF_clk</span>(clk),</span><br><span class="line">        <span class="variable">.Rdc</span>(Rdc),</span><br><span class="line">        <span class="variable">.Rsc</span>(Rsc),</span><br><span class="line">        <span class="variable">.Rtc</span>(Rtc),</span><br><span class="line">        <span class="variable">.Rd</span>(Rd),</span><br><span class="line">        <span class="variable">.Rs</span>(Rs),</span><br><span class="line">        <span class="variable">.Rt</span>(Rt),</span><br><span class="line">        <span class="variable">.RF_W</span>(RF_W)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    PcReg pcreg(</span><br><span class="line">        <span class="variable">.clk</span>(clk),</span><br><span class="line">        <span class="variable">.rst</span>(rst),</span><br><span class="line">        <span class="variable">.ena</span>(ena),</span><br><span class="line">        <span class="variable">.PR_in</span>(MUX_out[<span class="number">2</span>]),</span><br><span class="line">        <span class="variable">.PR_out</span>(PC)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    ALU alu(</span><br><span class="line">        <span class="variable">.A</span>(MUX_out[<span class="number">7</span>]),</span><br><span class="line">        <span class="variable">.B</span>(MUX_out[<span class="number">9</span>]),</span><br><span class="line">        <span class="variable">.Res</span>(Res),</span><br><span class="line">        <span class="variable">.ALUC</span>(ALUC),</span><br><span class="line">        <span class="variable">.zero</span>(ZF),  <span class="comment">// 0 is true, others are false</span></span><br><span class="line">        <span class="variable">.carry</span>(CF), <span class="comment">// unsigned cf</span></span><br><span class="line">        <span class="variable">.sign</span>(SF), <span class="comment">// 1 is false, 0 is true</span></span><br><span class="line">        <span class="variable">.overflow</span>(OF) <span class="comment">// signed of</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    Controller ctrl(</span><br><span class="line">        <span class="variable">.IM_instr</span>(IM_inst),</span><br><span class="line">        <span class="variable">.ZF</span>(ZF),</span><br><span class="line">        <span class="variable">.ALUC_out</span>(ALUC),</span><br><span class="line">        <span class="variable">.MUXC_out</span>(MUXC),</span><br><span class="line">        <span class="variable">.DMC_out</span>(&#123; DM_W, DM_R &#125;),</span><br><span class="line">        <span class="variable">.RFC_out</span>(&#123; RF_R, RF_W &#125;)</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>在这里呢，我把 Controller 也看做了一个译码器。<br>输入 Instruction，得到所有的控制信号。</p>
<p>我呢，一共使用了 10 个多路选择器。MUXC 是 [9:0]。<br>ALUC 对应着 ALU 的控制信号。<br>DM 的一些信号是向外层传输的。<br>RF 则是在内部消化了。</p>
<h4 id="7-sccomp-dataflow"><a href="#7-sccomp-dataflow" class="headerlink" title="7. sccomp_dataflow"></a>7. sccomp_dataflow</h4><p>为啥叫这个名字，并不是我在哪里看到了一份完整的 CPU31 代码，然后它叫这个，我就跟着叫这个名字了。<br>这个名字是官网文档在测试 cpu 那份 pdf 里写的。</p>
<p>我也不知道为啥叫这个。<br>总之到时候会调用这个名字的模块，不是这个名字应该就不行。<br>我们之前实现了 CPU31，这之后需要将 CPU 和 IMEM, DMEM 结合起来。<br>正如一开始的那张哈佛结构图一样。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> sccomp_dataflow(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> rst,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] inst,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] pc, <span class="comment">// to test</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">10</span>:<span class="number">0</span>] dm_addr,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">10</span>:<span class="number">0</span>] im_addr</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> dw, dr, dena;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] w_data, r_data;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] instr, pc, res;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">10</span>:<span class="number">0</span>] dm_addr;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] im_addr;</span><br><span class="line">    <span class="keyword">assign</span> inst = instr;</span><br><span class="line">    <span class="keyword">assign</span> dm_addr = (res - <span class="number">32'h10010000</span>) / <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    IMEM imemory(</span><br><span class="line">        <span class="variable">.addr</span>(im_addr[<span class="number">12</span>:<span class="number">2</span>]),</span><br><span class="line">        <span class="variable">.instr</span>(instr)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">assign</span> im_addr = pc - <span class="number">32'h0040_0000</span>;</span><br><span class="line">    DMEM dmemory(</span><br><span class="line">        <span class="variable">.clk</span>(clk), <span class="variable">.ena</span>(<span class="number">1'b1</span>), <span class="variable">.DM_W</span>(dw), <span class="variable">.DM_R</span>(dr), <span class="variable">.DM_addr</span>(dm_addr[<span class="number">10</span>:<span class="number">0</span>]), <span class="variable">.DM_wdata</span>(w_data),</span><br><span class="line">        <span class="variable">.DM_rdata</span>(r_data)</span><br><span class="line">    );</span><br><span class="line">    CPU31 cpu(</span><br><span class="line">        <span class="variable">.clk</span>(clk), <span class="variable">.ena</span>(<span class="number">1'b1</span>),<span class="variable">.rst</span>(rst), <span class="variable">.IM_inst</span>(instr), <span class="variable">.DM_rdata</span>(r_data),</span><br><span class="line">        <span class="variable">.DM_ena</span>(dena), <span class="variable">.DM_W</span>(dw), <span class="variable">.DM_R</span>(dr), <span class="variable">.DM_wdata</span>(w_data), <span class="variable">.PC_out</span>(pc), <span class="variable">.ALU_out</span>(res)</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>为什么 dm_addr 的值要除以 4，这是因为 mips 的数据段和代码段一样，都是隔 4 个单位才有一个新单元。</p>
<p><img src="5-26.png" alt="5-26"></p>
<p>但是我们自己写的 DMEM 可不是那么回事，我们写的 DMEM 是紧挨着的，所以要除以 4。<br>可 PC 却不用除以 4，IMEM 和 DMEM 之间的区别希望记住。</p>
<p>现在 CPU 已经写完了，但是可能还会出各种各样的问题，所以要进行测试。<br>对整体的测试依然使用 testbench：<br>（本 testbench 是我 debug 时自用的，<strong>并非验收时使用的 testbench</strong>，切记）</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> test_cpu(</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">reg</span> clk, rst;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] inst, pc;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] cnt;</span><br><span class="line">    <span class="keyword">wire</span>[<span class="number">10</span>:<span class="number">0</span>] dma, ima;</span><br><span class="line">    <span class="keyword">integer</span> file_open;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        clk = <span class="number">1'b0</span>;</span><br><span class="line">        rst = <span class="number">1'b1</span>;</span><br><span class="line">        #<span class="number">20</span> rst=<span class="number">1'b0</span>;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">        #<span class="number">20</span> clk = !clk;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        cnt &lt;= cnt + <span class="number">1'b1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">8'h99</span> - <span class="number">1</span>) <span class="keyword">begin</span> <span class="comment">// 可自我调整，这是所有 txt 测试文件都能够容纳的数据，在此时钟下，为6000 ns</span></span><br><span class="line">            file_open = <span class="built_in">$fopen</span>(<span class="string">"output.txt"</span>, <span class="string">"a"</span>);</span><br><span class="line">            <span class="built_in">$fdisplay</span>(file_open, <span class="string">"regfile = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">$fdisplay</span>(file_open, <span class="string">"regfile = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">$fdisplay</span>(file_open, <span class="string">"regfile = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">2</span>]);</span><br><span class="line">            <span class="built_in">$fdisplay</span>(file_open, <span class="string">"regfile = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">3</span>]);</span><br><span class="line">            <span class="built_in">$fdisplay</span>(file_open, <span class="string">"regfile = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">4</span>]);</span><br><span class="line">            <span class="built_in">$fdisplay</span>(file_open, <span class="string">"regfile = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">5</span>]);</span><br><span class="line">            <span class="built_in">$fdisplay</span>(file_open, <span class="string">"regfile = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">6</span>]);</span><br><span class="line">            <span class="built_in">$fdisplay</span>(file_open, <span class="string">"regfile = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">7</span>]);</span><br><span class="line">            <span class="built_in">$fdisplay</span>(file_open, <span class="string">"regfile = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">8</span>]);</span><br><span class="line">            <span class="built_in">$fdisplay</span>(file_open, <span class="string">"regfile = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">9</span>]);</span><br><span class="line">            <span class="built_in">$fdisplay</span>(file_open, <span class="string">"regfile = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">10</span>]);</span><br><span class="line">            <span class="built_in">$fdisplay</span>(file_open, <span class="string">"regfile = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">11</span>]);</span><br><span class="line">            <span class="built_in">$fdisplay</span>(file_open, <span class="string">"regfile = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">12</span>]);</span><br><span class="line">            <span class="built_in">$fdisplay</span>(file_open, <span class="string">"regfile = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">13</span>]);</span><br><span class="line">            <span class="built_in">$fdisplay</span>(file_open, <span class="string">"regfile = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">14</span>]);</span><br><span class="line">            <span class="built_in">$fdisplay</span>(file_open, <span class="string">"regfile = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">15</span>]);</span><br><span class="line">            <span class="built_in">$fdisplay</span>(file_open, <span class="string">"regfile = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">16</span>]);</span><br><span class="line">            <span class="built_in">$fdisplay</span>(file_open, <span class="string">"regfile = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">17</span>]);</span><br><span class="line">            <span class="built_in">$fdisplay</span>(file_open, <span class="string">"regfile = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">18</span>]);</span><br><span class="line">            <span class="built_in">$fdisplay</span>(file_open, <span class="string">"regfile = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">19</span>]);</span><br><span class="line">            <span class="built_in">$fdisplay</span>(file_open, <span class="string">"regfile = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">20</span>]);</span><br><span class="line">            <span class="built_in">$fdisplay</span>(file_open, <span class="string">"regfile = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">21</span>]);</span><br><span class="line">            <span class="built_in">$fdisplay</span>(file_open, <span class="string">"regfile = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">22</span>]);</span><br><span class="line">            <span class="built_in">$fdisplay</span>(file_open, <span class="string">"regfile = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">23</span>]);</span><br><span class="line">            <span class="built_in">$fdisplay</span>(file_open, <span class="string">"regfile = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">24</span>]);</span><br><span class="line">            <span class="built_in">$fdisplay</span>(file_open, <span class="string">"regfile = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">25</span>]);</span><br><span class="line">            <span class="built_in">$fdisplay</span>(file_open, <span class="string">"regfile = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">26</span>]);</span><br><span class="line">            <span class="built_in">$fdisplay</span>(file_open, <span class="string">"regfile = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">27</span>]);</span><br><span class="line">            <span class="built_in">$fdisplay</span>(file_open, <span class="string">"regfile = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">28</span>]);</span><br><span class="line">            <span class="built_in">$fdisplay</span>(file_open, <span class="string">"regfile = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">29</span>]);</span><br><span class="line">            <span class="built_in">$fdisplay</span>(file_open, <span class="string">"regfile = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">30</span>]);</span><br><span class="line">            <span class="built_in">$fdisplay</span>(file_open, <span class="string">"regfile = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">31</span>]);</span><br><span class="line">            <span class="built_in">$fclose</span>(file_open);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    sccomp_dataflow sc(</span><br><span class="line">        <span class="variable">.clk</span>(clk),</span><br><span class="line">        <span class="variable">.rst</span>(rst),</span><br><span class="line">        <span class="variable">.inst</span>(inst),</span><br><span class="line">        <span class="variable">.pc</span>(pc),</span><br><span class="line">        <span class="variable">.dm_addr</span>(dma), <span class="variable">.im_addr</span>(ima)</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这里还是给一个我推想出来的 testbench 文件：<br>（但是抱着不负责任的态度说一句，我没用过这个 tb 文件，这个文件是我在 markdown 里面直接写的，连有没有语法错误都不知道）</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> test();</span><br><span class="line">    <span class="keyword">reg</span> clk_in, reset;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] inst, pc;</span><br><span class="line">    <span class="keyword">integer</span> file_output;</span><br><span class="line">    <span class="keyword">integer</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        file_output = <span class="built_in">$fopen</span>(<span class="string">"result.txt"</span>);</span><br><span class="line">        clk_in = <span class="number">0</span>;</span><br><span class="line">        reset = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        #<span class="number">50</span>;</span><br><span class="line">        reset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">        #<span class="number">50</span>;</span><br><span class="line">        clk_in = ~clk_in;</span><br><span class="line">        <span class="keyword">if</span> (clk_in == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (counter == <span class="number">400</span>) <span class="keyword">begin</span></span><br><span class="line">                <span class="built_in">$fclose</span>(file_output);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                counter = counter + <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"pc: %h"</span>, pc);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"instr: %h"</span>, inst);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"regfile0 = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"regfile1 = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">1</span>]);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"regfile2 = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">2</span>]);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"regfile3 = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">3</span>]);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"regfile4 = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">4</span>]);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"regfile5 = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">5</span>]);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"regfile6 = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">6</span>]);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"regfile7 = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">7</span>]);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"regfile8 = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">8</span>]);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"regfile9 = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">9</span>]);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"regfile10 = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">10</span>]);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"regfile11 = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">11</span>]);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"regfile12 = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">12</span>]);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"regfile13 = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">13</span>]);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"regfile14 = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">14</span>]);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"regfile15 = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">15</span>]);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"regfile16 = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">16</span>]);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"regfile17 = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">17</span>]);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"regfile18 = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">18</span>]);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"regfile19 = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">19</span>]);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"regfile20 = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">20</span>]);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"regfile21 = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">21</span>]);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"regfile22 = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">22</span>]);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"regfile23 = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">23</span>]);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"regfile24 = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">24</span>]);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"regfile25 = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">25</span>]);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"regfile26 = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">26</span>]);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"regfile27 = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">27</span>]);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"regfile28 = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">28</span>]);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"regfile29 = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">29</span>]);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"regfile30 = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">30</span>]);</span><br><span class="line">                <span class="built_in">$fdisplay</span>(file_output, <span class="string">"regfile31 = %h"</span>, sc<span class="variable">.cpu</span><span class="variable">.Rf</span><span class="variable">.registers</span>[<span class="number">31</span>]);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    sccomp_dataflow sc(</span><br><span class="line">        <span class="variable">.clk_in</span>(clk_in), <span class="variable">.reset</span>(reset),</span><br><span class="line">        <span class="variable">.inst</span>(inst), <span class="variable">.pc</span>(pc)</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>通过系统函数的调用，可以将输出文件与 Mars 的运行结果进行比对。<br>这个模拟过程在一开始就已经提过了，不再赘述。</p>
<h3 id="七、写在最后"><a href="#七、写在最后" class="headerlink" title="七、写在最后"></a>七、写在最后</h3><p>一开始说自己只测了 7 条指令，还觉得自己稳了。<br>找借口说自己是太自（lan）信（duo）了，所以没有测完全部的 31 条指令。</p>
<p>的确是懒了，这是实话。但是全部测下来之后还是发现了很多问题，现在问题大多已更正。<br>但即便从一开始就有了写一篇的打算，并且当时把每个步骤发现的问题都记了下来，可是依旧不能保证踩尽人间坑。<br>上面的程序肯定也多多少少有些错误。</p>
<p>不过没有关系，我想说的差不多已经说完了，按照这个流程走下来应该能写出 CPU31 这个小实验。<br>最后想说句，自己写写 Mars 就能丰衣足食了。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://github.com/skyleaworlder" target="_blank" rel="noopener">skyleaworlder</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skyleaworlder.github.io/2020/06/18/CPU31/" target="_blank" rel="noopener">https://skyleaworlder.github.io/2020/06/18/CPU31/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OS/">OS</a><a class="post-meta__tags" href="/tags/%E4%BD%9C%E4%B8%9A/">作业</a></div><div class="post_share"><div class="social-share" data-image="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=3392122441,2459756568&amp;fm=15&amp;gp=0.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/07/11/filter-branch/"><img class="prev-cover" src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1598451793891&amp;di=9dcfe119119ca89368ca1751c008b953&amp;imgtype=0&amp;src=http%3A%2F%2Fi2.hdslb.com%2Fbfs%2Farchive%2F61e47cbf49e6ac21438f7bf439dac13c11022f17.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">减小 GitHub 仓库的体积</div></div></a></div><div class="next-post pull-right"><a href="/2020/06/05/mysql.sock/"><img class="next-cover" src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=4168175735,397291537&amp;fm=26&amp;gp=0.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">mysql.sock / mysqld.sock</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2020/05/29/ProTJec/" title="ProTJec"><img class="cover" src="/img/cover/ProTJec.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-29</div><div class="title">ProTJec</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By skyleaworlder</div><div class="framework-info"><span>Framework </span><a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener">Butterfly</a></div><div class="footer_custom_text">Hello! This is <a href="https://github.com/skyleaworlder" target="_blank" rel="noopener">skyleaworlder</a>...</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  var script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk({
      clientID: '47acdb8cdd05067e5096',
      clientSecret: '772acc69515bf271c73913a6b3c42de3508a6dd5',
      repo: 'skyleaworlder.github.io',
      owner: 'skyleaworlder',
      admin: ['skyleaworlder'],
      id: '9d85215cd75f83830c6bee3ac6cf44b7',
      language: 'zh-CN',
      perPage: 10,
      distractionFreeMode: false,
      pagerDirection: 'last',
      createIssueManually: true,
      updateCountCallback: commentCount
    })
    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    $.getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js', initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks"></canvas><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script></div></body></html>