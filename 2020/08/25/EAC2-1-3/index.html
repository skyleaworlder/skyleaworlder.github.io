<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>读书笔记-编译器设计（第一章到第三章） | 遐想的空中宫殿</title><meta name="description" content="Journals of Engineering a Compiler 2nd-Edition (chapter1 to chapter3)"><meta name="keywords" content="编译原理,读书笔记"><meta name="author" content="skyleaworlder"><meta name="copyright" content="skyleaworlder"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/skyleaworlder.png"><link rel="canonical" href="http://yoursite.com/2020/08/25/EAC2-1-3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="读书笔记-编译器设计（第一章到第三章）"><meta property="og:url" content="http://yoursite.com/2020/08/25/EAC2-1-3/"><meta property="og:site_name" content="遐想的空中宫殿"><meta property="og:description" content="Journals of Engineering a Compiler 2nd-Edition (chapter1 to chapter3)"><meta property="og:image" content="https://www.astateofdata.com/wp-content/uploads/2019/09/code-compiler-machine-code.png"><meta property="article:published_time" content="2020-08-25T07:43:02.000Z"><meta property="article:modified_time" content="2020-10-28T10:28:42.223Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '4.2.1',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime: '',
  date_suffix: {"one_hour":"Just","hours":"hours ago","day":"days ago"},
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-10-28 18:28:42'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/skyleaworlder.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">11</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#第一章-编译概观"><span class="toc-number">1.</span> <span class="toc-text">第一章 编译概观</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-编译器结构"><span class="toc-number">1.1.</span> <span class="toc-text">1.2 编译器结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-转换概述"><span class="toc-number">1.2.</span> <span class="toc-text">1.3 转换概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-前端"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.3.1 前端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-优化器"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.3.2 优化器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3-后端"><span class="toc-number">1.2.3.</span> <span class="toc-text">1.3.3 后端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-自己瞎-bb"><span class="toc-number">1.3.</span> <span class="toc-text">1.4 自己瞎 bb</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第二章-词法分析器"><span class="toc-number">2.</span> <span class="toc-text">第二章 词法分析器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-词法分析器"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 词法分析器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-识别单词"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 识别单词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-正则表达式-gt-词法分析器"><span class="toc-number">2.3.</span> <span class="toc-text">2.4 正则表达式 -&gt; 词法分析器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-正则表达式-gt-NFA-Thompson"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.4.2 正则表达式 -&gt; NFA: Thompson</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-NFA-gt-DFA-子集构造"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.4.3 NFA -&gt; DFA: 子集构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-4-DFA-gt-min-DFA-Hopcroft-Karp-Algorithm"><span class="toc-number">2.3.3.</span> <span class="toc-text">2.4.4 DFA -&gt; min DFA: Hopcroft-Karp Algorithm</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-5-识别器"><span class="toc-number">2.3.4.</span> <span class="toc-text">2.4.5 识别器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-词法分析器实现"><span class="toc-number">2.4.</span> <span class="toc-text">2.5 词法分析器实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1-表驱动"><span class="toc-number">2.4.1.</span> <span class="toc-text">2.5.1 表驱动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2-直接编码"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.5.2 直接编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-3-手工编码"><span class="toc-number">2.4.3.</span> <span class="toc-text">2.5.3 手工编码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-芜湖！起飞"><span class="toc-number">2.5.</span> <span class="toc-text">2.6 芜湖！起飞</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-3-无闭包的正则表达式"><span class="toc-number">2.5.1.</span> <span class="toc-text">2.6.3 无闭包的正则表达式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-自己瞎-bb"><span class="toc-number">2.6.</span> <span class="toc-text">2.7 自己瞎 bb</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第三章-语法分析器"><span class="toc-number">3.</span> <span class="toc-text">第三章 语法分析器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-提及词法分析器"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 提及词法分析器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-语法"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-上下文无关语法"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1 上下文无关语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-将语义编码到结构中"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.4 将语义编码到结构中</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-自顶向下语法分析"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 自顶向下语法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-左递归"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1 左递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-无回溯"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.3.2 无回溯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-FIRST-Set-amp-FOLLOW-Set"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.3.3 FIRST Set &amp; FOLLOW Set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-4-左因子提取消除回溯"><span class="toc-number">3.3.4.</span> <span class="toc-text">3.3.4 左因子提取消除回溯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-5-自顶向下的递归下降语法分析器"><span class="toc-number">3.3.5.</span> <span class="toc-text">3.3.5 自顶向下的递归下降语法分析器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-表驱动的-LL-1-语法分析器"><span class="toc-number">3.3.6.</span> <span class="toc-text">3.3.3 表驱动的 LL(1) 语法分析器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-自底向上语法分析"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 自底向上语法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-LR-1-语法分析算法"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.4.1 LR(1) 语法分析算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-实际问题"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 实际问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-1-错误恢复"><span class="toc-number">3.5.1.</span> <span class="toc-text">3.5.1 错误恢复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-3-二义性"><span class="toc-number">3.5.2.</span> <span class="toc-text">3.5.3 二义性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-4-左-右结合"><span class="toc-number">3.5.3.</span> <span class="toc-text">3.5.4 左 &#x2F; 右结合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-高级玩意儿"><span class="toc-number">3.6.</span> <span class="toc-text">3.6 高级玩意儿</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-1-语法优化"><span class="toc-number">3.6.1.</span> <span class="toc-text">3.6.1 语法优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-2-表格优化"><span class="toc-number">3.6.2.</span> <span class="toc-text">3.6.2 表格优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-自己瞎-bb"><span class="toc-number">3.7.</span> <span class="toc-text">3.7 自己瞎 bb</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://www.astateofdata.com/wp-content/uploads/2019/09/code-compiler-machine-code.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">遐想的空中宫殿</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">读书笔记-编译器设计（第一章到第三章）</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-08-25T07:43:02.000Z" title="Created 2020-08-25 15:43:02">2020-08-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2020-10-28T10:28:42.223Z" title="Updated 2020-10-28 18:28:42">2020-10-28</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">9.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>30min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>（2020/8/19 22:59 ~ 2020/8/25 15:39）</p>
<blockquote>
<p>尽量不抄书吧。</p>
<p>希望我翻书的时候是个人，而不是个机器。</p>
</blockquote>
<h2 id="第一章-编译概观"><a href="#第一章-编译概观" class="headerlink" title="第一章 编译概观"></a>第一章 编译概观</h2><h3 id="1-2-编译器结构"><a href="#1-2-编译器结构" class="headerlink" title="1.2 编译器结构"></a>1.2 编译器结构</h3><p><img src="EAC2-1-3/1.png" alt="1"></p>
<p>编译器的简单目的就是 “把一种语言转换成另一种语言” 的程序。<br>尽管中间还要加许多用作限制的修饰词，本质来说，应该就是 “翻译” 的功能。当然说 “翻译” 也不好，毕竟 “口译” 的英文就是 <code>Interpret</code>，又和 “解释” 扯上莫名其妙的关系了…</p>
<p>（图上的 <code>IR</code> 指的是 <code>Intermediate Representation</code> (中间表示)，好像写 CPU 的时候，某个文档中的图也有 <code>IR</code> 这个简称，当时还以为是 <code>Instructions balabala</code>。）</p>
<p><img src="EAC2-1-3/2.png" alt="2"></p>
<p>后面附了张加 <strong>优化器</strong> 的图，我想这个，正常人类应该很好理解。<br>在优化器中，<code>IR</code> 转换为更有效率的 <code>IR</code>。想必前端解析出来的 <code>IR</code> 直接用在后端上会对后端处理产生很大的威胁吧，我现在也不知道。</p>
<p>至于为什么一个编译器要分做 <strong>前端</strong> 和 <strong>后端</strong>。看了下还真和我想的一样。</p>
<blockquote>
<p>如果有 $M$ 种语言，$N$ 种 <a href="https://en.wikipedia.org/wiki/Comparison_of_instruction_set_architectures" target="_blank" rel="noopener"><code>ISA</code></a>。<br>假设不存在前端与后端的概念，一种语言转换为一种指令集就是一个编译器，这样得有 $MN$ 个编译器。<br>但是假设前端和后端分开，约定好输入输出的前提下，只会有 $M + N$ 个部件，而它们组合起来就是编译器。</p>
</blockquote>
<p>刚刚是直考虑这个 $M N$ 问题中的前后端，实际上还有 <code>IR</code> 呢。我想 <code>IR</code> 肯定不会是特定的，即使给定了源语言和目标语言，<code>IR</code> 也不一定就是唯一的，所以还是要实现很多的前后端吧…</p>
<p>（其实 $M + N$ 怪理想的，也不可能直接拼起来就能用吧？不会吧不会吧？）</p>
<h3 id="1-3-转换概述"><a href="#1-3-转换概述" class="headerlink" title="1.3 转换概述"></a>1.3 转换概述</h3><h4 id="1-3-1-前端"><a href="#1-3-1-前端" class="headerlink" title="1.3.1 前端"></a>1.3.1 前端</h4><p>前端（哦，没想到这里也是 <code>front end</code> 写作前端），旨在检查程序，并生成 <code>IR</code> 格式的输出。</p>
<blockquote>
<p>The front-end deals with the language itself: scanning, parsing, the parse-tree.</p>
</blockquote>
<p>书里面举的是英文的例子。我想对于编程语言的话，那些：</p>
<script type="math/tex; mode=display">
\begin{cases}
Sentence \to Subject \ verb \ Object \ endmark \\
\\
Subject \to noun \\
\\
Subject \to Modifier \ noun \\
\\
... \\
\end{cases}</script><p>大概就是 $Assignment \to variable \ AssignSyb \ variable \ endmark$ 吧。</p>
<p>写数据库作业的时候，就看到学长发说说吐槽作业太多，这才第一次正式听说词法分析器、语法分析器这两个词。现在看的话，这两个就是前端大多数任务的担当了。</p>
<p><img src="EAC2-1-3/3.png" alt="3"></p>
<p>三个大的方框内，又有一些小的圆角矩形，每一个圆角矩形都代表 <strong>一趟</strong>。<br>算了算了，还是直接抄书吧：</p>
<ol>
<li>词法分析器：将字符构成的串转换为单词构成的流。</li>
<li>语法分析器：判断输入流是否是源语言的一个句子。</li>
<li>类型检查：检查输入程序中对名字的使用在类型方面是否一致。</li>
</ol>
<p>听起来蛮合理的，编译时报的错貌似就这些了吧（应该是？）</p>
<h4 id="1-3-2-优化器"><a href="#1-3-2-优化器" class="headerlink" title="1.3.2 优化器"></a>1.3.2 优化器</h4><p>gcc 那个 -O2 -O3 应该就是优化器的选项了吧。<br>这里提到了一个 <code>数据流分析</code> 的名词，听说是个复杂的操作。</p>
<p>除了分析之外，还有转换。人写代码，总是会因各种各样的问题而写出一堆很废的代码，比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bound_i = <span class="number">3</span>, bound_j = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> index, jndex;</span><br><span class="line"><span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; bound_i; ++index)</span><br><span class="line">    <span class="keyword">for</span> (jndex = <span class="number">0</span>; jndex &lt; bound_j; ++jndex)</span><br><span class="line">        arr[jndex][index] = jndex * <span class="number">4</span> + index + bound_i * bound_j;</span><br></pre></td></tr></table></figure>
<p>但万一这么写，是为了在人类角度看更容易理解呢（？）<br>这种程度的代码…相信编译器可以扳过来吧。<br>（如果我写了一个阶模乘，强大的现代编译器会不会把它优化成蒙哥马利乘呢…）</p>
<h4 id="1-3-3-后端"><a href="#1-3-3-后端" class="headerlink" title="1.3.3 后端"></a>1.3.3 后端</h4><blockquote>
<p>The back-end deals with the target system.<br>Object code formats, the machine code itself and so on.</p>
</blockquote>
<p>不管是哪里的寄存器，反正汇编语言很多指令都要涉及寄存器。反汇编一个可执行文件，能看到很多寄存器标号。而这些或许是源程序中没有写明的。（要都写明了，为啥不直接写汇编…）</p>
<p>书中举的例子是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t &lt;- 2 * a * b * c * d</span><br></pre></td></tr></table></figure>
<p>为了让这个句子变成汇编语句，中间还有许多步骤。比如 <strong>决定右端乘法的顺序</strong>、<strong>加载数值</strong>、<strong>最终指令执行的顺序</strong>。</p>
<p>至于运算（乘法）的顺序，对于这个语句，如果这些 a, b, c, d 什么的就是整数，而不代表什么其他东西，那我仅凭我现在的认识，怎么乘都无所谓吧。</p>
<p>加载数值的话，要考虑寄存器的个数。寄存器里面一直都有值，但是那个值究竟之后 <strong>会不会被再次利用</strong> 却不一定。<br>数量有限、存取效率高的寄存器放在那里，一直不用就等于自废武功。为了加速，寄存器肯定是要极大化利用的。<br>现在只有这一条语句，即使加上所有的中间结果，那也不会超出 10 个，远远小于正常计算机内部的寄存器个数。但是程序一大起来，就不好判断哪一个寄存器是一直不用的了。<br>仔细一想，如果存在这么一个专门搞人的变量，开头用两三次，结尾再根据某个靠后的计算结果用一次。在程序中间运行的时候，的确它还会被利用，但是占着茅坑和上面说的自废武功又有何异233。像这种恶心人的变量，直接写回 <strong>最最最最底层的存储器</strong> 才是它应得的下场吧。</p>
<p>指令的执行顺序嘛。只要你不对我负责，我也不对你负责，那就随便绿。最少的周期，执行最多的指令，一开口就是老时间管理了。<br>和 <strong>体系结构课教的那个流水线</strong> 是差不多的道理。如果前后两个指令有交集，那我在不切换指令的前提下，除了 <strong>bubble</strong> 也没啥办法了。</p>
<h3 id="1-4-自己瞎-bb"><a href="#1-4-自己瞎-bb" class="headerlink" title="1.4 自己瞎 bb"></a>1.4 自己瞎 bb</h3><p>没上大学的时候，总会有远大的理想。具体的体现是 <strong>敢看知乎</strong>。<br>知乎上的个个都是人才，高考结束看完龙书的，大一第一个月就发 paper 的，我人都看傻了。后来，愈发认清自己，也就佛起来了。</p>
<p>编译器的确是个好玩意儿。</p>
<p><img src="EAC2-1-3/4.png" alt="4"></p>
<p>以前不了解，当然现在也不了解，就觉得编译器不就是个把 c 转成汇编的玩意儿吗。<br>但仔细一想，如果这种转换真就那么简单的话，为什么还要高级语言呢？</p>
<h2 id="第二章-词法分析器"><a href="#第二章-词法分析器" class="headerlink" title="第二章 词法分析器"></a>第二章 词法分析器</h2><h3 id="2-1-词法分析器"><a href="#2-1-词法分析器" class="headerlink" title="2.1 词法分析器"></a>2.1 词法分析器</h3><p>读了一点点，以本人目前的水平，词法分析器还是蛮难的嘛…但是书中说，这个部件已经算是简单的了。</p>
<p>其实平时写程序的时候，就想过：</p>
<ol>
<li><code>try</code> <code>except</code> 这些关键字是怎么判断的？</li>
<li>一个句子是怎么判断出来的？</li>
<li>怎么能判断句子的合理性？</li>
</ol>
<p>好吧这些问题或许有个答案了。上学期上了门 <strong>形式语言与自动机</strong>。我想除了哈工大、北航等大学，正常的大学都没有这门课吧？（大多数我猜都是合着 <strong>编译原理</strong> 一起上的）</p>
<p>比如 <code>while</code>，就可以通过一个自动机识别：</p>
<p><img src="EAC2-1-3/5.png" alt="5"></p>
<p>我就用书上的图，反正意思到位了就行。<code>try except</code> 这两个关键字也可以这么识别出来。<br>但是如果把一个小小的 <code>while</code> 放在庞大的程序代码中，读到 <strong>w</strong> 了，如何选择？如何判断？我还是很不清楚的。</p>
<p>一个句子怎么判断出来。这个也有点头绪。比如 C 语言，如果按照规范写，那是每行一句，可是每行也有可能存在多句话，所以应该把 <strong>遇到分号</strong> 算作一句话的中止。<br>但是还有比较复杂的情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (index &lt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wtf? %d"</span>, index); <span class="comment">// first</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, index); <span class="comment">// second</span></span><br></pre></td></tr></table></figure>
<p>对于 <code>first</code> 而言，很好就可以判断分号是这句话的结束。但是对于下一句话，却需要在 <code>printf</code> 的第一个字母时算作开始。中间差了一个 <code>}</code>。<br>当然，要说的话，关于 <code>{</code>，我猜是有一个栈的。</p>
<ol>
<li><strong>栈空仍弹出 <code>}</code></strong> 会报错；</li>
<li><code>}</code> 前必须是一个完整的句子。<ol>
<li>其后要么仍是 <code>}</code>；</li>
<li>要么表示下一个句子的开始。</li>
<li>…</li>
</ol>
</li>
</ol>
<p>对于句子的合理性，我想的是会设定出一系列的规则。这些规则分布在各趟中。词法分析器的规则，只是去读词，读句子。在不顾及语义的前提下，分析句子们。</p>
<h3 id="2-2-识别单词"><a href="#2-2-识别单词" class="headerlink" title="2.2 识别单词"></a>2.2 识别单词</h3><p>书上的识别单词就是使用 <strong>形式化语言 和 自动机</strong> 讲的。<br>像 <code>try except while</code> 这些关键字，只需要上面那张图的自动机就可以识别。<br>即使是遇到有些字母相同的，比如：<code>double &amp; do</code>，也可以这样实现：</p>
<p><img src="EAC2-1-3/6.png" alt="6"></p>
<p>对于数字，那就更方便了。浮点有浮点的正则表达式：</p>
<script type="math/tex; mode=display">
(0 | (1-9)(0-9)^*).(\epsilon | (0-9)*)</script><p>事实是怎样，就写成怎样。<br>对于 C 语言的 <strong>注释 (/* */ 以及 //)</strong>，也会有类似的表示方法，只要所有都考虑周全。（然而考虑周全是件不简单的事）</p>
<h3 id="2-4-正则表达式-gt-词法分析器"><a href="#2-4-正则表达式-gt-词法分析器" class="headerlink" title="2.4 正则表达式 -&gt; 词法分析器"></a>2.4 正则表达式 -&gt; 词法分析器</h3><p>又开始 <strong>形式语言与自动机</strong> 了。我决定跳过这些 <strong>DFA, NFA</strong>。<br>这书写的哪里都挺好，就是老给后面挖坑，然后等着后面来填。填倒是应该都填了，不然大家对这本书评价不会这么搞。但是我也不是每天早七点、晚五点坐等 《编译器设计》的更新。记不住的记不住的。</p>
<h4 id="2-4-2-正则表达式-gt-NFA-Thompson"><a href="#2-4-2-正则表达式-gt-NFA-Thompson" class="headerlink" title="2.4.2 正则表达式 -&gt; NFA: Thompson"></a>2.4.2 正则表达式 -&gt; NFA: Thompson</h4><p><code>Thompson&#39;s Construction</code> 是个好活。正常人看了之后都能学会 <code>RE -&gt; NFA</code>。</p>
<p><img src="EAC2-1-3/7.png" alt="7"></p>
<p>书上画的比较详细。我还找了某个 <a href="https://en.wikipedia.org/wiki/Thompson%27s_construction" target="_blank" rel="noopener">不存在的百科网站</a> 的图，我觉得画的更好：</p>
<p><img src="EAC2-1-3/11.png" alt="11"></p>
<p><img src="EAC2-1-3/12.png" alt="12"></p>
<p><img src="EAC2-1-3/9.png" alt="9"></p>
<p><img src="EAC2-1-3/8.png" alt="8"></p>
<p><img src="EAC2-1-3/10.png" alt="10"></p>
<p>图片有点大，不过没关系。<br>对于 <code>ab</code> 的 <code>NFA</code> 要注意的是中间还要经过一次 <code>epsilon</code>。不存在百科的图里，中间跨越 <code>N</code> 的时候需要经过 <code>epsilon</code>。</p>
<p>对于 <code>a|b</code> 的 <code>NFA</code>，百科有如下解释：</p>
<blockquote>
<p>State q goes via epsilon either to the initial state of N(s) or N(t).<br>Their final states become the intermediate states of the whole NFA.<br>And merge via two epsilon-transitions into the final state of NFA.</p>
</blockquote>
<p>根据 <code>Thompson&#39;s Construction</code>，<strong>利用 RE 的优先级顺序画出一个树</strong>，这样后通过一个 <code>RE</code> 随便画出一个符合要求的 <code>NFA</code> 根本不是什么难事。麻烦的是如何把 <code>NFA</code> 转换为等价的 <code>DFA</code>。</p>
<h4 id="2-4-3-NFA-gt-DFA-子集构造"><a href="#2-4-3-NFA-gt-DFA-子集构造" class="headerlink" title="2.4.3 NFA -&gt; DFA: 子集构造"></a>2.4.3 NFA -&gt; DFA: 子集构造</h4><p>与其叫 <strong>子集构造法</strong>，不如叫 <strong>幂集构造(Powerset Construction)</strong>。</p>
<p>这个算法光看书上写的那几段干条条，肯定脑壳大。所以还是用不存在百科的图：</p>
<p><img src="EAC2-1-3/13.png" alt="13"></p>
<p><code>NFA</code> 按照书上的定义:</p>
<blockquote>
<p>允许在空串输入 $\epsilon$ 上进行转移的 <code>FA</code>，<br>其状态对同一字符输入可能有多种转移。</p>
</blockquote>
<p>用人话说，<code>NFA</code> 就是 0/1 能大于 1 个去处，并且能有 <code>epsilon-transition</code> 的有穷自动机。</p>
<p>下面这个图是 <strong>确定性有穷自动机</strong>，每个状态 $A$ 的出度 $d^+(A) \le 2$，但是入度不一定。<br>（当前这个图的转移就是用的 <strong>0/1</strong>，所以出度 ≤ 2）<br>（尽管状态里面是一个集合，而非数字，那也是 <strong>DFA</strong>。发出转移，也是以 <strong>集合的身份</strong> 发出的，而非 <strong>集合中的元素</strong>。画的时候，抽象点写 $q_0, q_1…$ 这些状态符号可以代表很多东西）</p>
<p><img src="EAC2-1-3/14.png" alt="14"></p>
<p>有一说一，<code>JFLAP</code> 中将 <code>NFA</code> 转换为 <code>DFA</code> 的方法也是这样的。</p>
<p>凡事都有个开头，<code>NFA</code> 都有唯一的起始状态 $q_0$，以此为原点，将所有可以由 $q_0$ 进行 <code>epsilon-transition</code> 得到的状态，全部纳入新 <code>DFA</code> 的起始节点的 <strong>集合</strong> 中。</p>
<p>之后遍历新 <code>DFA</code> 的起始节点的 <strong>集合</strong>，通过原 <code>NFA</code> 的 $\delta_N$ 得到新 <code>DFA</code> 的所有节点。</p>
<p>书中有言：</p>
<blockquote>
<p>算法每前进一步，就从 <code>WorkList</code> 中删除一个集合 $q$。<br>每个 $q$ 都表示原来的 <code>NFA</code> 中一个有效的配置。</p>
</blockquote>
<p>我真的不觉得这句话很容易被读懂。</p>
<p>上学期学 <strong>算法设计与分析</strong> 的时候，课本上讲过 <a href="https://afteracademy.com/blog/print-all-subsets-of-a-given-set" target="_blank" rel="noopener">子集树</a> 这个概念。<br>所有状态全部以 <strong>0/1</strong> 表示，<strong>q 个状态可以有 $2^q$ 个子集</strong>。</p>
<p><img src="EAC2-1-3/15.png" alt="15"></p>
<p>为什么不存在百科上，没有把这个算法叫做 <code>Subset Construction</code>，而叫做 <code>Powerset Construction</code>。我想原因就是这里。</p>
<p>算法进行一步，都从 <code>WorkList</code> 中删除一个集合 $q$。<br>这句话等价于 <strong>算法每进行一步，都有一个状态生成，且 DFA 中的状态不可重复</strong>。<br>生成了一个新状态，就好比少了一种 <strong>未来可能生成的新状态</strong>。（因为要是生成了旧状态，<strong>直接转移</strong> 就完事儿了）</p>
<p>至于 <strong>子集构造</strong> 啥时候结束，不增长了就结束呗。</p>
<h4 id="2-4-4-DFA-gt-min-DFA-Hopcroft-Karp-Algorithm"><a href="#2-4-4-DFA-gt-min-DFA-Hopcroft-Karp-Algorithm" class="headerlink" title="2.4.4 DFA -&gt; min DFA: Hopcroft-Karp Algorithm"></a>2.4.4 DFA -&gt; min DFA: Hopcroft-Karp Algorithm</h4><p>爷学不会。<br>下学期开学之后再看。</p>
<h4 id="2-4-5-识别器"><a href="#2-4-5-识别器" class="headerlink" title="2.4.5 识别器"></a>2.4.5 识别器</h4><ul>
<li>识别一个 “拎出来” 的单词：</li>
<li>识别 “variable1+variable2”<ul>
<li>要求结束于 <strong>易识别</strong> 的分隔符 -&gt; “variable1 + variable2 “；</li>
<li><strong>分隔符</strong> 必须环绕 <strong>单词</strong> -&gt; “ variable1 + variable2 “；</li>
<li>一直匹配下去，<strong>即使遇到了可接受状态</strong>，直至无路可走：<ul>
<li>到了可接受状态 -&gt; <strong>成功识别</strong>；</li>
<li>为不可接受状态 -&gt; <strong>返回上一个的可接受状态</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>可接收状态是个集合，分不出来到底是什么单词 -&gt; 返回优先级最高的。</li>
</ul>
<h3 id="2-5-词法分析器实现"><a href="#2-5-词法分析器实现" class="headerlink" title="2.5 词法分析器实现"></a>2.5 词法分析器实现</h3><h4 id="2-5-1-表驱动"><a href="#2-5-1-表驱动" class="headerlink" title="2.5.1 表驱动"></a>2.5.1 表驱动</h4><p>昨晚睡觉之前搜了分词法分析器代码。看样子就是 <strong>表驱动</strong> 的。<br>前面书上画了好多状态机，所以从最最基础的来写，肯定连识别关键字都要自动机的写法。但是也可以 <code>strcmp</code> 呀。</p>
<p><img src="EAC2-1-3/16.png" alt="16"></p>
<p>这张图前面又是一堆文字。其实看文字也看得懂，这段还不至于，还不至于。但是这段伪码有 3 个地方是应该说明的。</p>
<ol>
<li>为了只保存 <strong>最后一个可接受状态</strong>；</li>
<li>说明跳出循环还有可能是 <code>state</code> 为 <code>bad</code>，<strong>栈空了</strong>，这样最后的 <code>if</code> 条件就不成立；</li>
<li><code>truncate</code> 是 <code>lexeme + char</code> 的反义词。</li>
</ol>
<p>这段代码是为了 <strong>表示寄存器的名字（$r[0-9]^+$）</strong>。</p>
<ul>
<li>第一部分用于初始化；</li>
<li>第二部分根据输入流，运行如转移表 $\delta$ 中描述的 <code>DFA</code>；</li>
<li>第三部分处理无路可走时 <strong>处在不可接收状态</strong> 的情况；</li>
<li>第四部分判断合理性。</li>
</ul>
<p>多亏 ASCII 表是像现在这样设计的，不然或许会多写很多代码。</p>
<p>后面书上给出了一个 <strong>最长适配词法分析器</strong>，但是没细看了。<br>算法是给定的，只要还在做 <strong>词法分析</strong> 这件事，那么算法就不需要改变。</p>
<p>会 / 需要改变的是 <strong>正则表达式 / 自动机 / 转移表</strong>。<br>而 <strong>表驱动词法分析器</strong>，（表驱动表驱动）应该能够适配 <strong>所有</strong> 可能的转移表，一旦转移表给定，就能够对于输入给出输出。</p>
<h4 id="2-5-2-直接编码"><a href="#2-5-2-直接编码" class="headerlink" title="2.5.2 直接编码"></a>2.5.2 直接编码</h4><p>这种毫无疑问是最符合人类眼球的。</p>
<p><img src="EAC2-1-3/17.png" alt="17"></p>
<p>我想说这不是一眼就看得出来怎么回事？<br>直接编码书中说：<code>无需显示表示 DFA  的当前状态和转移图，而是使用专门的代码片段来实现每个状态</code>。<br>但是看起来明显比 <strong>代码实现的状态和转移逻辑</strong> 更清楚。</p>
<p>当然，这也仅仅限于少数几个状态。如果状态一多，那 <strong>直接编码式</strong> 的代码写法就和一般的 <strong>自动机</strong> 没有什么区别了。<br>即使使用精心挑选的变量名，也还是不如抽象出 <strong>表跳转逻辑</strong> 的代码好看。</p>
<h4 id="2-5-3-手工编码"><a href="#2-5-3-手工编码" class="headerlink" title="2.5.3 手工编码"></a>2.5.3 手工编码</h4><p><img src="EAC2-1-3/18.png" alt="18"></p>
<p>所以说 <code>DFA</code> 就是逊啊。逐字符的输入使用 <code>DFA</code> 是很容易实现，但是 I/O 耗时多。<br>后面书上给了 <code>NextChar, RollBack</code> 的两段伪码。我是没看出来为啥 <code>Fence &lt;- (Input + n) mod 2n</code>，我怎么想都觉得是 <code>Input - n</code>。难不成作为 <strong>有效缓冲区起始地址</strong> 的 <code>Fence</code> 还跑到前面去了吗？</p>
<h3 id="2-6-芜湖！起飞"><a href="#2-6-芜湖！起飞" class="headerlink" title="2.6 芜湖！起飞"></a>2.6 芜湖！起飞</h3><h4 id="2-6-3-无闭包的正则表达式"><a href="#2-6-3-无闭包的正则表达式" class="headerlink" title="2.6.3 无闭包的正则表达式"></a>2.6.3 无闭包的正则表达式</h4><p><img src="EAC2-1-3/19.png" alt="19"></p>
<p>需要识别的字符串（键）有多长，就会经过多少个状态。</p>
<blockquote>
<p>用这种方法生成的 <code>DFA</code> 不能保证是最小的。<br>显然上图中的 “eed” 三个字母代表的状态可以合并。<br>无环 <code>DFA</code> 是 <strong>完美散列函数</strong> 的替代方案，当键值较少时，无环 <code>DFA</code> 可以表现为一个快速的识别器。<br>但随着键值增加、键长增加，散列会更快。</p>
</blockquote>
<h3 id="2-7-自己瞎-bb"><a href="#2-7-自己瞎-bb" class="headerlink" title="2.7 自己瞎 bb"></a>2.7 自己瞎 bb</h3><p>回顾了一下，好像 <strong>词法分析器</strong> 和我最开始自己想的那个概念不太像。<br>在这里，词法分析器仅仅就是判断 <strong>单词可否接受</strong> 而已。</p>
<p>无论应用的工具如何变化（<code>DFA / NFA / RE</code>），使用的算法又是怎样（<code>Thompson / Powerset / Hopcroft-Karp</code>），采取的又是何种策略（表驱动 / 直接编码 / 手工编码），最终的目的都是基于一个 <strong>自动机</strong>，写出足以描述自动机 <strong>转移函数</strong>，并具备 <strong>回滚能力</strong> 的词法分析器。</p>
<p>说是基于自动机，那是因为：</p>
<blockquote>
<p>我想，即使是 <code>NFA</code>，应该程序也能模拟吧，只不过是困难一些。<br>毕竟 <code>NFA</code> 转换为 <code>DFA</code> 的算法在那里写着呢。</p>
</blockquote>
<p><code>NFA</code> 当然可以，但是 <code>DFA</code> 肯定更简单，最简化的 <code>DFA</code> 更是如此。</p>
<p>这让我想起上 <strong>离散数学</strong> 的时候，有个同学跟我说的一句话：</p>
<blockquote>
<p>看起来很枯燥，但是每一章节都对应计算机领域的一些应用。</p>
</blockquote>
<h2 id="第三章-语法分析器"><a href="#第三章-语法分析器" class="headerlink" title="第三章 语法分析器"></a>第三章 语法分析器</h2><h3 id="3-1-提及词法分析器"><a href="#3-1-提及词法分析器" class="headerlink" title="3.1 提及词法分析器"></a>3.1 提及词法分析器</h3><p>词法分析器，词法分析器，顾名思义就是把输入进来的 <strong>字符串流</strong> 转换成一个个 <strong>单词流</strong>。词法分析器中又有单词的类型，所以词法分析器的输出是 <strong>归类单词流</strong>。</p>
<ol>
<li>归类，表示给出某单词的 “词性”，比如：<code>&lt;&quot;123.4&quot;, &quot;number:float&quot;&gt;, &lt;&quot;switch&quot;, &quot;reserved&quot;&gt;</code> 之类；</li>
<li>单词，表示词法分析器已经把 <strong>串</strong> 转化为 <strong>单词</strong>（不知道有没有分隔符什么的）；</li>
<li>流，表示分析好的单词与词性组成的 “数据结构”。</li>
</ol>
<h3 id="3-2-语法"><a href="#3-2-语法" class="headerlink" title="3.2 语法"></a>3.2 语法</h3><p>毫无疑问，语法分析器上编译原理的时候是要写的。啊这，所以得好好看呀。</p>
<p>平常还是经常把 “语法” 两个字挂在嘴边的嘛。某个地方标了红线，就 “哦，语法不对”。<br>反而变量名、标识符这些写错，不会下意识弹出来一句 “哦！词法不对”。</p>
<p>语法分析器，字面意思是要分析语法，可是分析之前得先认识语法。</p>
<h4 id="3-2-1-上下文无关语法"><a href="#3-2-1-上下文无关语法" class="headerlink" title="3.2.1 上下文无关语法"></a>3.2.1 上下文无关语法</h4><p>有一说一，爷这部分上课的时候是没学好的。<br>我连为什么这里讲语法分析器 <strong>不用 RE 而用 CFG 都不知道</strong>。</p>
<p>那么感谢 <code>KDL&amp;LT</code> 让我明白了我早该明白的道理。</p>
<p>对于 $a \times b + c \div d$，这个式子。</p>
<ul>
<li>按照 <code>RE</code> 的角度来，那是读了就读了。<ol>
<li>看到 $a$，存一下。</li>
<li>看到 $\times$，赶快读下一个 $b$，立刻计算，将结果计为 $tmp1$。</li>
<li>看到 $+$，立刻把 $tmp1$ 和 $c$ 放一起进行加法运算得到结果 $tmp2$。</li>
<li>看到 $\div$，迅速将 $d$ 作除数，$tmp2$ 作被除数。</li>
<li>最后输出了结果。实际的计算顺序等价于：$((a \times b) + c) \div d$。</li>
</ol>
</li>
<li>按照 <code>CFG</code> 的角度来，还要进行优先级的判断。<code>CFG</code> 能够做到完全是因为它有一个 <strong>栈</strong>。<ul>
<li>反正就是正常人类的计算方式。</li>
<li>但是也可以定义非人类的计算方式，比如 $\times$ 优先，$+$ 其次，$\div$ 最后…</li>
</ul>
</li>
</ul>
<p>在正则语言中，如果使用后面的 <code>推导式</code> 来写，那么无论是怎样的正则表达式，都必定受限于：</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; a</span><br><span class="line">  |  aB</span><br></pre></td></tr></table></figure>
<p>（这里 <code>A, B</code> 指的是变元，<code>a</code> 是终结符，当然，这里的 <code>A -&gt; aB</code> 和 <code>A -&gt; a</code> 都不一定只有一个）<br>（由于 <code>a</code> 为输入，<code>B</code> 代表下一个状态，因此只是形式必须是这样的形式）</p>
<p>可以想象，这样的语言是不配被分析语法的（？）<br>退一百步说，连一般的算术表达式都无法保证优先级，更何况其他运算符的优先级顺序呢。</p>
<p>书中一直在举 <strong>优先级</strong> 的例子。这是因为语言，大部分就是优先级之间的考量，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!((<span class="number">2</span> + <span class="number">4</span>) &gt;&gt; <span class="number">1</span> &gt; <span class="number">3.5</span>))</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">int</span>(<span class="keyword">double</span>(<span class="number">2.5</span> / <span class="number">6.0</span>) + <span class="number">0.8</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>诚然，里面需要识别 <code>cout</code> 究竟是什么，需要数清 <code>{ }</code> 的匹配关系。<br>但是的确涉及了许多优先级，<code>!, ::, &lt;&lt;, &gt;&gt;, ()</code>…<br>所以，<code>RE</code> 不行。</p>
<p>但是 <code>RE</code> 这种推导式在构成串上，却是极好的。<br>这也是为什么 <strong>词法分析器针对 <code>DFA</code>，而语法分析器分析的是 <code>CFG</code></strong>。</p>
<p><img src="EAC2-1-3/20.png" alt="20"></p>
<p><img src="EAC2-1-3/21.png" alt="21"></p>
<blockquote>
<p>最右推导 (<code>Right Most Derivation</code>)，书上写的是：“一种在每个步骤都 <strong>重写最右侧的 非终结符</strong> 的推导”<br>按照个人理解，就是给定一个串，从起始符号开始，使用推导式，按照串 <strong>从右向左，由外及内</strong> 的顺序，推导出和给定串一样的串。</p>
</blockquote>
<p>纯个人理解，<code>L(G)</code> 存在二义性，表现在对于一个 <strong>可接受状态</strong>，不仅存在多条路径抵达，而且相同过程的个数相等。（或许有问题）</p>
<p><img src="EAC2-1-3/22.png" alt="22"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if Expr1 then</span><br><span class="line">    if Expr2 then</span><br><span class="line">        Assignment1</span><br><span class="line">    else</span><br><span class="line">        Assignment2</span><br><span class="line"></span><br><span class="line">if Expr1 then</span><br><span class="line">    if Expr2 then</span><br><span class="line">        Assignment1</span><br><span class="line">else</span><br><span class="line">    Assignment2</span><br></pre></td></tr></table></figure>
<p>（相较于没有 <code>then</code>，有了 <code>then</code> 并没有什么用）</p>
<p>所以说 <code>C</code> 会在没有 <code>{}</code> 的前提下，选择第一种作为默认方案（即使写成第二种），而同时允许两种情况存在的 <code>Python</code> 会选择用 <strong>缩进</strong> 来标识。</p>
<p>同时，为了避免上面这种情况发生，才有了 <code>else if</code>。</p>
<h4 id="3-2-4-将语义编码到结构中"><a href="#3-2-4-将语义编码到结构中" class="headerlink" title="3.2.4 将语义编码到结构中"></a>3.2.4 将语义编码到结构中</h4><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Goal -&gt; Expr</span><br><span class="line"></span><br><span class="line">Expr -&gt; Expr + Term</span><br><span class="line">     |  Expr - Term</span><br><span class="line">     |  Term</span><br><span class="line"></span><br><span class="line">Term -&gt; Term * Factor</span><br><span class="line">     |  Term / Factor</span><br><span class="line">     |  Factor</span><br><span class="line"></span><br><span class="line">Factor -&gt; ( Expr )</span><br><span class="line">       |  num</span><br><span class="line">       |  name</span><br></pre></td></tr></table></figure>
<p>一组推导式，明眼人一眼就看出括号的优先级最高。而最先被推导出来的 <code>+/-</code> 却是优先级最低的。<br>毕竟越先推出来，位于语法分析树的层是越高的，肯定越后参与运算。</p>
<p>到底是先看层高的（根），还是层低的（叶子），就会分成两种分析方式。</p>
<h3 id="3-3-自顶向下语法分析"><a href="#3-3-自顶向下语法分析" class="headerlink" title="3.3 自顶向下语法分析"></a>3.3 自顶向下语法分析</h3><p><img src="EAC2-1-3/23.png" alt="23"></p>
<p>这代码还蛮好懂的。</p>
<ul>
<li>第一，<code>if</code> 里把 <code>focus</code> 会把关注点放在 <strong>当前节点的最左子节点</strong> 上；</li>
<li>第二，<code>else if</code> 表明当前为终结符，下一个读入的居然还能匹配语法；（比如 <code>int a = 3;;</code> 吧）</li>
<li>第三，<code>else if</code> 指分析成功；</li>
<li>第四，<code>else</code> 指的是匹配失败，需要 <strong>回退</strong>。</li>
</ul>
<p>回退到什么地方，和 <code>if</code> 块中的操作有关。应该去尝试其他的规则。如果同级规则都不匹配，<strong>需要将输入流恢复原状</strong>，之后再匹配上一级规则。</p>
<p>但是这样会面临一个问题。<br>这个问题我记得 <strong>形式语言自动机</strong> 给我们讲过的，可是翻课件翻不到…</p>
<h4 id="3-3-1-左递归"><a href="#3-3-1-左递归" class="headerlink" title="3.3.1 左递归"></a>3.3.1 左递归</h4><p>假设 <strong>当前节点不是根节点</strong>。<br>目前，关注点正放在 <strong>当前节点的最左子节点</strong> 上。但是 <strong>当前节点</strong> 也是其父节点的 <strong>最左子节点</strong>。那么，既然其父节点能够产生一个 <strong>可以继续产生子节点</strong> 的节点，其本身的最左子节点应该也 <strong>可 以相同推导式 继续产生子节点</strong>。也就是说，<strong>绝不可能通过持续关注最左子节点，使得推导结果全为终结符</strong>。<br>（具体情况，类似数学归纳法：<code>A</code> 家的孩子随母姓 <code>A</code>，并且只留女儿。现在 <code>A</code> 家存在一个女性，育有女儿，那么这家未来的所有女性都姓 <code>A</code>）</p>
<p><img src="EAC2-1-3/24.png" alt="24"></p>
<p>这是我觉得很有问题的一张图。我是觉得应该：</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Expr' -&gt; epsilon</span><br><span class="line">      |  - Term Expr'</span><br><span class="line">      |  + Term Expr'</span><br></pre></td></tr></table></figure>
<p><img src="EAC2-1-3/25.png" alt="25"></p>
<p><img src="EAC2-1-3/26.png" alt="26"></p>
<p>比如这张图。当然，要说的话，书上写的是 <strong>右递归</strong>，可是也没人硬定义一个左右呢（就硬抬）<br>需要注意的是，虽说是从 $\epsilon$ 开始，但是并不是什么时候都推成 $\epsilon$，遇到了符号，就要变成符号！！！！（比如 <code>name Expr&#39; -&gt; name + Term Expr&#39;</code>，就是用的第 2 条）</p>
<p>消除左递归，有两种方法，第一种是这样加 $\epsilon$，另外一种就是交叉写推导式。<br>但无论如何，消除左递归，只是解决 <strong>左递归</strong> 这一个问题。</p>
<h4 id="3-3-2-无回溯"><a href="#3-3-2-无回溯" class="headerlink" title="3.3.2 无回溯"></a>3.3.2 无回溯</h4><blockquote>
<p>必须说明这样一个令人痛苦的事实：<br>不是所有的 <code>CFG</code> 都有无回溯语法。<br>时刻记住，<code>lookahead symbol</code> 是为了杀 <strong>左递归</strong>，左因子提取是为了杀 <strong><code>lookahead symbol</code> 的无效化</strong>；消除左递归 <strong>不等于</strong> 产生无回溯语法。</p>
</blockquote>
<p>人在考试做 <strong>语法分析树</strong> 题目的时候，为什么能一下子写出正确的推导过程？（当然也不排除我因 nt 写偏，甚至做错的可能）<br>这是因为人可以看题目！如果题目只能看一次的话，那就是人的记性好！</p>
<p>好吧，其实是因为人在判断用哪条推导式的时候，不仅仅根据自己 <strong>已经推导到了的位置</strong>，还会根据 <strong>未来才会读到的单词</strong> 进行判断。</p>
<blockquote>
<p>对上面那个语法而言，语法分析器可以利用一个简单的修改来避免回溯。在语法分析器去选择下一条规则时，它可以 <strong>同时考虑当前关注的符号以及下一个输入符号</strong>，称为前瞻符号 (lookahead symbol)。<br>通过前瞻一个符号，语法分析器可以消除在解析 <strong>右递归表达式语法</strong> 时 <strong>多种选择</strong> 造成的不确定性。</p>
</blockquote>
<p>你以为我只看到 <code>name</code>，实际上我连 <code>name</code> 后面的加号都看到了。一切都是 <code>lookahead symbol</code> 中注定。</p>
<h4 id="3-3-3-FIRST-Set-amp-FOLLOW-Set"><a href="#3-3-3-FIRST-Set-amp-FOLLOW-Set" class="headerlink" title="3.3.3 FIRST Set &amp; FOLLOW Set"></a>3.3.3 FIRST Set &amp; FOLLOW Set</h4><blockquote>
<p>FIRST 集合指的是：对于 $\alpha$，FIRST($\alpha$) 是从 $\alpha$ 推导出的 <strong>语句开头</strong> 可能出现的 <strong>终结符</strong> 的集合。</p>
</blockquote>
<p><img src="EAC2-1-3/27.png" alt="27"></p>
<blockquote>
<p>FOLLOW 集合指的是：对于 <strong>非终结符</strong> $\alpha$，FOLLOW($\alpha$) 是在语句中 <strong>紧接</strong> 着 $\alpha$ 出现的 <strong>单词</strong> 的集合。</p>
</blockquote>
<p>（我硬是觉得这个表有问题）<br>所以有关这两个集合，之后我学了再聊。</p>
<p><img src="EAC2-1-3/28.png" alt="28"></p>
<blockquote>
<p>$FIRST^+(A \to \beta) = FIRST(\beta) \quad if \ \epsilon \ \notin \ FIRST(\beta)$</p>
<p>$FIRST^+(A \to \beta) = FIRST(\beta) \ \bigcup \ FOLLOW(A) \quad else$</p>
</blockquote>
<p><img src="EAC2-1-3/32.png" alt="32"></p>
<h4 id="3-3-4-左因子提取消除回溯"><a href="#3-3-4-左因子提取消除回溯" class="headerlink" title="3.3.4 左因子提取消除回溯"></a>3.3.4 左因子提取消除回溯</h4><p>对于函数调用，的确 <code>lookahead symbol</code> 就不管用了：</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Factor -&gt; name</span><br><span class="line">       |  name [ArgList]</span><br><span class="line">       |  name (ArgList)</span><br><span class="line">ArgList -&gt; Expr MoreArgs</span><br><span class="line">MoreArgs -&gt; , Expr MoreArgs</span><br><span class="line">         | epsilon</span><br></pre></td></tr></table></figure>
<p>关于 <code>Factor</code> 的三个推导式都是 <code>name...</code>，导致根本无法通过下一个符号（这里指 <code>name</code>）来知晓到底选择哪条推导式。<br>于是 <strong>左因子提取</strong> 呼之欲出，我甚至连啥是左因子提取都没兴趣继续写了，因为太明显。</p>
<h4 id="3-3-5-自顶向下的递归下降语法分析器"><a href="#3-3-5-自顶向下的递归下降语法分析器" class="headerlink" title="3.3.5 自顶向下的递归下降语法分析器"></a>3.3.5 自顶向下的递归下降语法分析器</h4><p>递归下降… 一个不熟悉的名词。<br>对于一个简单的三结果推导式：</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                        FIRST+</span><br><span class="line">Expr' -&gt; + Term Expr'   &#123;+&#125;</span><br><span class="line">      |  - Term Expr'   &#123;-&#125;</span><br><span class="line">      |  epsilon        &#123;epsilon, eof, )&#125;</span><br></pre></td></tr></table></figure>
<p><img src="EAC2-1-3/29.png" alt="29"></p>
<p>书上说了两段话，但是都不如这段程序清楚。<br>试想，程序处理代码文本，根据当前的表达式，如果现在是 <strong>最左推导</strong> 的话，顺序利用 <code>lookahead symbol</code> 拿到下一个 <code>word</code> 之后，会根据当前 <code>Expr&#39;</code> 的 <code>FIRST+</code> 进入程序框中的 <code>if-elseif-else</code>。</p>
<p>如果是前两条推导式，那么还需要判断下一个 <code>word</code> 是否是 <code>Term</code>，如果是的话，就需要对下一个 <code>Expr&#39;</code> 进行 <code>EPrime</code> 处理。</p>
<p>如果忘记了 <code>Expr&#39;</code> 是什么，可以参照之前的图：（<code>Expr&#39; Term&#39;</code> 都是为了防止 <strong>左递归</strong> 而所作的改进，并采取 <strong>右递归</strong> 避免）</p>
<p><img src="EAC2-1-3/24.png" alt="24"></p>
<p>如此可以看出，只要是一个非终结符(<code>Expr&#39;</code>)，就需要进行 <code>EPrime</code> 的处理。所以写了一个递归。</p>
<p><img src="EAC2-1-3/30.png" alt="30"></p>
<h4 id="3-3-3-表驱动的-LL-1-语法分析器"><a href="#3-3-3-表驱动的-LL-1-语法分析器" class="headerlink" title="3.3.3 表驱动的 LL(1) 语法分析器"></a>3.3.3 表驱动的 LL(1) 语法分析器</h4><p>由于只是看个理论，先了解一下，所以暂时并没有以自己写出来一个语法分析器为最终目标，这才一切都过的这么快。实际上上一章节应该需要看更久时间的。上一节的内容实际上应该已经提供了完成一个 <strong>简单语法分析器</strong> 的所有理论知识。</p>
<p>通过 <code>FIRST+, FOLLOW, FIRST</code>，可以给语法分析器提供非常多的信息。<br>其中，<code>FIRST+</code> 又是最早接触、最为重要的集合。<code>LL(1)</code> 的意思就是：</p>
<blockquote>
<p>由左（Left, L）到右扫描输入；<br>构建一个最左推导（Leftmost, L）；<br>其中只使用 1 个 <code>lookahead symbol</code>（1）。</p>
</blockquote>
<p><img src="EAC2-1-3/31.png" alt="31"></p>
<p>上面说那几个集合等学了之后再看，但是不摸清那三个集合，这些玩意儿完全理解不了啊。<br>根据我没理解的那个 <code>FIRST+</code> 集合，生成了如下这张表：</p>
<p><img src="EAC2-1-3/33.png" alt="33"></p>
<p><img src="EAC2-1-3/34.png" alt="34"></p>
<p>（注：上面的数字就是 <code>FIRST+</code> 中的序号，比如 8，对照一下上面的 <code>FIRST+</code> 就知道了）<br>通过 3-11 这个图，以及 3-13 图，就能知道 <code>LL(1)</code> 已经开始有了自己的逻辑，并且作为 <strong>无回溯算法</strong>，整体运行十分高效。</p>
<p>与之前的普通语法分析器不一样，之前的是从左向右，依次读取，并将生成的 <code>Factor -&gt; terminal</code> 放置在左侧。但是 <code>LL(1)</code> 利用了一个栈，用于存储解析需要使用的 <code>Expr&#39; Term&#39; Factor</code> 等符号，并且一旦生成与输入相匹配的 <code>word</code>，就会弹出，从而继续生成 <code>word</code>。</p>
<p>并且 <code>LL(1)</code> 语法分析器的步骤清晰明了：</p>
<ol>
<li>生成可用的 <code>FIRST, FOLLOW, FIRST+</code>，进而生成 <code>Table</code>；</li>
<li>初始化栈、<code>focus</code>；</li>
<li><strong>从左向右</strong> 输入被分析文本，通过 <code>lookahead symbol</code> 可以获知下一个 <code>word</code>；</li>
<li>使用获知的下一个 <code>word</code> 查找 <code>Table</code>，得到使用的规则（<strong>循环</strong>）；</li>
<li>直至 <strong>终结符</strong> 出现，弹出终结符，继续输入文本，重复第 4 步；</li>
<li>直至输入文本为 <code>epsilon/eof</code>，且栈中仅有 <code>eof（栈底符号）</code>，终止程序。</li>
</ol>
<p>在第 4 步，一旦下一个 <code>word</code> 使得当前 <code>Expr&#39; Term&#39; Factor</code> 不存在 <strong>与之对应的规则</strong>，那么说明 <strong>语法错误！</strong> 芜湖！</p>
<p>妙，太妙了。<br>爷看了下目录，后面还有什么 <code>LR(1)</code>，我不管那个分析器多么高效，至少这个 <code>LL(1)</code> 我看懂了！（或许吧）<br>而且我觉得很舒服，整体下来没有什么多余的地方（除了 <code>Table</code> 消耗的空间或许会很大之外），我现在猛吹 <code>LL(1)</code> 嗷。</p>
<p>因此，不得不说这种做法相较于之前的 <strong>右递归经典分析法</strong> 有着许多优势。</p>
<h3 id="3-4-自底向上语法分析"><a href="#3-4-自底向上语法分析" class="headerlink" title="3.4 自底向上语法分析"></a>3.4 自底向上语法分析</h3><p>顾名思义。<strong>自顶而下</strong> 指的是一切由 <code>Goal</code> 起始，通过一系列推导式，做到 <strong>道生一，一生二， 二生三，三生万物</strong>。<br>那么 <strong>自底而上</strong>，按照个人理解，就是 <strong>百川东入海</strong>。文本输入至语法分析器，考察的不再是如自顶而下一般的 <strong>能否生成与输入文本相同的终结符串</strong>，而是看最终能不能归于 <code>Goal</code>。</p>
<p>这个…过程想起来不难，但是具体到实现现在看起来还有点困难的啊。在不知道任何背景和辅助工具的前提下，想起来也是一个复杂度阶乘的玩意儿。</p>
<p>不过仅仅是了解到这里，我也能不通过书了解到一个事实：</p>
<blockquote>
<p>这自底向上不存在左递归问题啊！</p>
</blockquote>
<p>对于自顶向下而言，是需要对输入的规则进行处理的，不然一旦左递归，就是无止境的循环。</p>
<p>对于产生式 $A \to \beta$，可以用字母 $k$ 替换，那么就称 $(A \to \beta, k)$ 为一个 <strong>句柄</strong>。</p>
<p>然后，爷第一次知道归约的英文是 <code>reduction</code>，我的天，我形式语言自动机上课在干什么，拿良果然是自作自受。对于一个无歧义的语法，最右推导是唯一的。</p>
<p><code>LR(1)</code> 顾名思义，就是要从左向右输入，做一个 <strong>最右推导</strong>。</p>
<h4 id="3-4-1-LR-1-语法分析算法"><a href="#3-4-1-LR-1-语法分析算法" class="headerlink" title="3.4.1 LR(1) 语法分析算法"></a>3.4.1 LR(1) 语法分析算法</h4><p><img src="EAC2-1-3/35.png" alt="35"></p>
<p><img src="EAC2-1-3/36.png" alt="36"></p>
<p>话不多说，先放两张图。<br>从程序当中可以看到，<code>LR(1)</code> 完全按照 <code>Action, Goto</code> 两个表来完成归约。</p>
<p><img src="EAC2-1-3/37.png" alt="37"></p>
<p>然后跟着这个关于 <code>(())()</code> 解析的过程走一遍，就大概明白 <code>LR(1)</code> 在做什么了。<br>所谓的 <code>shift</code> 实际是根据 <code>lookahead symbol</code> 选择正确的转移。</p>
<p><img src="EAC2-1-3/38.png" alt="38"></p>
<p>我是觉得没有 <code>LL(1)</code> 好。</p>
<h3 id="3-5-实际问题"><a href="#3-5-实际问题" class="headerlink" title="3.5 实际问题"></a>3.5 实际问题</h3><h4 id="3-5-1-错误恢复"><a href="#3-5-1-错误恢复" class="headerlink" title="3.5.1 错误恢复"></a>3.5.1 错误恢复</h4><p>对哈，编译器报错每次又不是只报一个错！应该得要一种方法来恢复当前的错误，以便于继续分析程序。<br>做法是先到一个错误的状态中继续输入文本，直到匹配上一个地方，就立刻复活。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b, c;</span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line">b = c + <span class="number">2</span>;</span><br><span class="line">c = <span class="number">6</span>;</span><br><span class="line">d = a + c;</span><br><span class="line">a = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>就比如这段程序，我寻思看到 <code>b = c + 2;</code> 之后，应该就进入错误状态了吧，但读到 <code>c = 6;</code> 时又原地复活，后面读到 <code>d = a + c;</code> 又死，之后再复活。</p>
<h4 id="3-5-3-二义性"><a href="#3-5-3-二义性" class="headerlink" title="3.5.3 二义性"></a>3.5.3 二义性</h4><p>书中说，<code>FORTRAN</code> 的数组和函数都是用的圆括号。那么按理来说就无法进行区分。<br>这里书中给出了两种解决方法：</p>
<ol>
<li>允许问题在语法分析器中存在，将问题留给后续的 <strong>转换过程</strong>，利用 <strong>声明取得的类型信息</strong> 解决；</li>
<li>在词法分析器和语法分析器中构建协议，明确 <strong>先定义再使用</strong>，以便将复合的推导式分解为 <strong>FuncRef -&gt; func-name( ArgList )</strong> 以及 <strong>ArrRef -&gt; arr-name( ArgList )</strong></li>
</ol>
<h4 id="3-5-4-左-右结合"><a href="#3-5-4-左-右结合" class="headerlink" title="3.5.4 左 / 右结合"></a>3.5.4 左 / 右结合</h4><p>我不想提及左 / 右递归对栈深度的影响。我更愿意想更顺的左 / 右递归对运算的结合性影响。<br>通过上面的了解，左递归必定导致左结合，右递归必定导致右结合。在有括号严格限制的情况下，两种结合方式在正常人类运算范畴都能处理的很好。但是一旦缺少括号，右结合便不符合正常人类数值计算的大脑。</p>
<p><code>a - b + c</code> 不可能等价于 <code>a - (b + c)</code>，除非 <code>c = 0</code>。所以使用右递归固然有优势，但是此时此刻，也需要进行左递归。书中管这个叫做 <strong>左递归和右递归之间的折中</strong>。</p>
<h3 id="3-6-高级玩意儿"><a href="#3-6-高级玩意儿" class="headerlink" title="3.6 高级玩意儿"></a>3.6 高级玩意儿</h3><h4 id="3-6-1-语法优化"><a href="#3-6-1-语法优化" class="headerlink" title="3.6.1 语法优化"></a>3.6.1 语法优化</h4><p>对于 <code>LR(1)</code> 语法分析器，我没有怎么细看。但是也能够理解，它不再需要使用一些特殊方法消除左递归。那么就不需要 <strong>将其推导式复杂化</strong>。</p>
<p>对于如下：</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Goal -&gt; Expr</span><br><span class="line">Expr -&gt; Expr + Term</span><br><span class="line">     |  Expr - Term</span><br><span class="line">     |  Term</span><br><span class="line">Term -&gt; Term * Factor</span><br><span class="line">     |  Term / Factor</span><br><span class="line">     |  Factor</span><br><span class="line">Factor -&gt; ( Expr )</span><br><span class="line">       |  num</span><br><span class="line">       |  name</span><br></pre></td></tr></table></figure>
<p>这样的推导式，甚至可以删去中间无用的符号，来减少递归时的时间消耗：</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Term -&gt; Term * ( Expr )</span><br><span class="line">     |  Term * name</span><br><span class="line">     |  ...</span><br></pre></td></tr></table></figure>
<p>比如这样，就缩去了 <code>Factor</code> 的三个推导式。<br>但是按道理说，是可以直接写到 <code>Goal</code> 那里的。可是这样，和分析一条语句又有什么差别呢？<br>对于比较简短的推导式，可以缩去，但是如果推导式较为复杂，考虑的情况也就多了起来。</p>
<p>比如上面的 <code>Term, Factor</code> 两个非终结符，均有 <strong>三条</strong> 推导式。那么如若将 <code>Factor</code> 缩进 <code>Term</code> 中，势必会出现 <strong>3*3 = 9</strong> 条推导式。（不能小于 9 的原因是 <strong>不允许二义性出现</strong>）</p>
<h4 id="3-6-2-表格优化"><a href="#3-6-2-表格优化" class="headerlink" title="3.6.2 表格优化"></a>3.6.2 表格优化</h4><p>或许之前提到过。</p>
<p>对于 <code>LR(1)</code> 语法分析器而言，一旦推导式数目增加，<code>Action, Goto</code> 两个表格消耗的空间也会增加。</p>
<p><strong>行列合并</strong> 是一种方法。通过建立一个 <strong>多对一</strong> 的映射关系表，有 MySQL 内味儿了。<br>第二种方法是统一部分非终结符名称。比如说整型和浮点型都是数字，类似这样。书中只介绍了 <code>LL(1), LR(1)</code> 两种语法分析器。大体上都是从左向右输入，但是具体的处理手段不同。除了这两种之外，还有其他的方法。</p>
<h3 id="3-7-自己瞎-bb"><a href="#3-7-自己瞎-bb" class="headerlink" title="3.7 自己瞎 bb"></a>3.7 自己瞎 bb</h3><p>书中也写了：</p>
<blockquote>
<p>自顶向下的递归下降语法分析器有自身的一些优势。<br>可以证明它们最容易以手工编码方式构建的语法分析器。</p>
</blockquote>
<p>果然啊，我的智力水平也就仅限于此了吗（？）<br>然后书中还说了一句：</p>
<blockquote>
<p>… 因而，从现成的语法分析器生成器开始，总比从头开始实现一个语法分析器生成器要好。</p>
</blockquote>
<p>哈哈哈哈哈…</p>
<p>除了书中写的这些之外，果然读书的是会面临各种各样的问题。脑子一天运行的时间有限这是其一，其二是明明知道静下心来看就能看明白，但是还是静不下来…</p>
<p>不免有些伤心了。</p>
<p>比如 <code>LR(1)</code> 那一部分，就没有特别仔细去看，当然也就没有了解，只是大致浏览了一遍的程度而已。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://github.com/skyleaworlder" target="_blank" rel="noopener">skyleaworlder</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skyleaworlder.github.io/2020/08/25/EAC2-1-3/" target="_blank" rel="noopener">https://skyleaworlder.github.io/2020/08/25/EAC2-1-3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a><a class="post-meta__tags" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></div><div class="post_share"><div class="social-share" data-image="https://www.astateofdata.com/wp-content/uploads/2019/09/code-compiler-machine-code.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/08/26/newTheme/"><img class="prev-cover" src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=169677197,1739806802&amp;fm=26&amp;gp=0.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">New Theme! 终于换好看的主题了</div></div></a></div><div class="next-post pull-right"><a href="/2020/07/11/filter-branch/"><img class="next-cover" src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1598451793891&amp;di=9dcfe119119ca89368ca1751c008b953&amp;imgtype=0&amp;src=http%3A%2F%2Fi2.hdslb.com%2Fbfs%2Farchive%2F61e47cbf49e6ac21438f7bf439dac13c11022f17.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">减小 GitHub 仓库的体积</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By skyleaworlder</div><div class="framework-info"><span>Framework </span><a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener">Butterfly</a></div><div class="footer_custom_text">Hello! This is <a href="https://github.com/skyleaworlder" target="_blank" rel="noopener">skyleaworlder</a>...</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  var script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk({
      clientID: '47acdb8cdd05067e5096',
      clientSecret: '772acc69515bf271c73913a6b3c42de3508a6dd5',
      repo: 'skyleaworlder.github.io',
      owner: 'skyleaworlder',
      admin: ['skyleaworlder'],
      id: 'd28e0460746d12799072fac7e7cca339',
      language: 'zh-CN',
      perPage: 10,
      distractionFreeMode: false,
      pagerDirection: 'last',
      createIssueManually: true,
      updateCountCallback: commentCount
    })
    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    $.getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js', initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks"></canvas><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script></div></body></html>